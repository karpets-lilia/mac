"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint-disable @typescript-eslint/no-unused-vars */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmModule = exports.NpmCommand = void 0;
const os_1 = require("os");
const path = require("path");
const npm_run_path_1 = require("npm-run-path");
const shelljs = require("shelljs");
const core_1 = require("@salesforce/core");
class NpmCommand {
    static runNpmCmd(cmd, options = {}) {
        const nodeExecutable = NpmCommand.findNode(options.cliRoot);
        const npmCli = NpmCommand.npmCli();
        const command = `"${nodeExecutable}" "${npmCli}" ${cmd} --registry=${options.registry} --json`;
        const npmShowResult = shelljs.exec(command, {
            ...options,
            silent: true,
            fatal: true,
            async: false,
            env: npm_run_path_1.default.env({ env: process.env }),
        });
        if (npmShowResult.code !== 0) {
            throw new core_1.SfdxError(npmShowResult.stderr, 'ShellExecError');
        }
        try {
            return JSON.parse(npmShowResult.stdout);
        }
        catch (error) {
            throw new core_1.SfdxError(error, 'ShellParseError');
        }
    }
    static npmPackagePath() {
        return this.npmPkgPath;
    }
    /**
     * Returns the path to the npm-cli.js file in this package's node_modules
     *
     * @private
     */
    static npmCli() {
        const pkgPath = NpmCommand.npmPackagePath();
        const pkgJson = core_1.fs.readJsonSync(pkgPath);
        const prjPath = pkgPath.substring(0, pkgPath.lastIndexOf(path.sep));
        return path.join(prjPath, pkgJson.bin['npm']);
    }
    /**
     * Locate node executable and return its absolute path
     * First it tries to locate the node executable on the root path passed in
     * If not found then tries to use whatver 'node' resolves to on the user's PATH
     * If found return absolute path to the executable
     * If the node executable cannot be found, an error is thrown
     *
     * @private
     */
    static findNode(root = undefined) {
        const isExecutable = (filepath) => {
            if (os_1.type() === 'Windows_NT')
                return filepath.endsWith('node.exe');
            try {
                if (filepath.endsWith('node')) {
                    // This checks if the filepath is executable on Mac or Linux, if it is not it errors.
                    core_1.fs.accessSync(filepath, core_1.fs.constants.X_OK);
                    return true;
                }
            }
            catch {
                return false;
            }
            return false;
        };
        if (root) {
            const sfdxBinDirs = NpmCommand.findSfdxBinDirs(root);
            if (sfdxBinDirs.length > 0) {
                // Find the node executable
                const node = shelljs.find(sfdxBinDirs).filter((file) => isExecutable(file))[0];
                if (node) {
                    return core_1.fs.realpathSync(node);
                }
            }
        }
        // Check to see if node is installed
        const nodeShellString = shelljs.which('node');
        if ((nodeShellString === null || nodeShellString === void 0 ? void 0 : nodeShellString.code) === 0 && (nodeShellString === null || nodeShellString === void 0 ? void 0 : nodeShellString.stdout))
            return nodeShellString.stdout;
        throw new core_1.SfdxError('Cannot locate node executable.', 'CannotFindNodeExecutable');
    }
    /**
     * Finds the bin directory in the sfdx installation root path
     *
     * @param sfdxPath
     * @private
     */
    static findSfdxBinDirs(sfdxPath) {
        return sfdxPath
            ? [path.join(sfdxPath, 'bin'), path.join(sfdxPath, 'client', 'bin')].filter((p) => core_1.fs.existsSync(p))
            : [];
    }
}
exports.NpmCommand = NpmCommand;
NpmCommand.npmPkgPath = require.resolve('npm/package.json');
class NpmModule {
    constructor(module, version = 'latest', cliRoot = undefined) {
        this.module = module;
        this.version = version;
        this.cliRoot = cliRoot;
        this.npmMeta = {
            moduleName: module,
        };
    }
    show(registry) {
        return NpmCommand.runNpmCmd(`show ${this.module}@${this.version}`, { registry, cliRoot: this.cliRoot });
    }
    pack(registry, options) {
        NpmCommand.runNpmCmd(`pack ${this.module}@${this.version}`, { ...options, registry, cliRoot: this.cliRoot });
        return;
    }
}
exports.NpmModule = NpmModule;
//# sourceMappingURL=npmCommand.js.map