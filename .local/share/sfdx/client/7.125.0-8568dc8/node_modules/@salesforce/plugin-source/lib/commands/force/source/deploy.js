"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deploy = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const deployCommand_1 = require("../../../deployCommand");
const componentSetBuilder_1 = require("../../../componentSetBuilder");
const deployResultFormatter_1 = require("../../../formatters/deployResultFormatter");
const deployAsyncResultFormatter_1 = require("../../../formatters/deployAsyncResultFormatter");
const deployProgressBarFormatter_1 = require("../../../formatters/deployProgressBarFormatter");
const deployProgressStatusFormatter_1 = require("../../../formatters/deployProgressStatusFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'deploy');
class Deploy extends deployCommand_1.DeployCommand {
    constructor() {
        super(...arguments);
        this.xorFlags = ['manifest', 'metadata', 'sourcepath', 'validateddeployrequestid'];
        this.lifecycleEventNames = ['predeploy', 'postdeploy'];
        this.isAsync = false;
        this.isRest = false;
        this.updateDeployId = (0, kit_1.once)((id) => {
            this.displayDeployId(id);
            this.setStash(id);
        });
    }
    async run() {
        await this.deploy();
        this.resolveSuccess();
        return this.formatResult();
    }
    // There are 3 types of deploys:
    //   1. synchronous - deploy metadata and wait for the deploy to complete.
    //   2. asynchronous - deploy metadata and immediately return.
    //   3. recent validation - deploy metadata that's already been validated by the org
    async deploy() {
        // verify that the user defined one of: manifest, metadata, sourcepath, validateddeployrequestid
        this.validateFlags();
        const waitDuration = this.getFlag('wait');
        this.isAsync = waitDuration.quantity === 0;
        this.isRest = await this.isRestDeploy();
        this.ux.log(`*** Deploying with ${this.isRest ? 'REST' : 'SOAP'} API ***`);
        if (this.flags.validateddeployrequestid) {
            this.deployResult = await this.deployRecentValidation();
        }
        else {
            this.componentSet = await componentSetBuilder_1.ComponentSetBuilder.build({
                apiversion: this.getFlag('apiversion'),
                sourceapiversion: await this.getSourceApiVersion(),
                sourcepath: this.getFlag('sourcepath'),
                manifest: this.flags.manifest && {
                    manifestPath: this.getFlag('manifest'),
                    directoryPaths: this.getPackageDirs(),
                    destructiveChangesPre: this.getFlag('predestructivechanges'),
                    destructiveChangesPost: this.getFlag('postdestructivechanges'),
                },
                metadata: this.flags.metadata && {
                    metadataEntries: this.getFlag('metadata'),
                    directoryPaths: this.getPackageDirs(),
                },
            });
            // fire predeploy event for sync and async deploys
            await this.lifecycle.emit('predeploy', this.componentSet.toArray());
            const deploy = await this.componentSet.deploy({
                usernameOrConnection: this.org.getUsername(),
                apiOptions: {
                    ignoreWarnings: this.getFlag('ignorewarnings', false),
                    rollbackOnError: !this.getFlag('ignoreerrors', false),
                    checkOnly: this.getFlag('checkonly', false),
                    runTests: this.getFlag('runtests'),
                    testLevel: this.getFlag('testlevel'),
                    rest: this.isRest,
                },
            });
            this.asyncDeployResult = { id: deploy.id };
            this.updateDeployId(deploy.id);
            if (!this.isAsync) {
                // we're not print JSON output
                if (!this.isJsonOutput()) {
                    const progressFormatter = kit_1.env.getBoolean('SFDX_USE_PROGRESS_BAR', true)
                        ? new deployProgressBarFormatter_1.DeployProgressBarFormatter(this.logger, this.ux)
                        : new deployProgressStatusFormatter_1.DeployProgressStatusFormatter(this.logger, this.ux);
                    progressFormatter.progress(deploy);
                }
                this.deployResult = await deploy.pollStatus(500, waitDuration.seconds);
            }
        }
        if (this.deployResult) {
            // Only fire the postdeploy event when we have results. I.e., not async.
            await this.lifecycle.emit('postdeploy', this.deployResult);
        }
    }
    /**
     * Checks the response status to determine whether the deploy was successful.
     * Async deploys are successful unless an error is thrown, which resolves as
     * unsuccessful in oclif.
     */
    resolveSuccess() {
        if (!this.isAsync) {
            const status = (0, ts_types_1.getString)(this.deployResult, 'response.status');
            if (status !== source_deploy_retrieve_1.RequestStatus.Succeeded) {
                this.setExitCode(1);
            }
        }
    }
    formatResult() {
        const formatterOptions = {
            verbose: this.getFlag('verbose', false),
        };
        let formatter;
        if (this.isAsync) {
            formatter = new deployAsyncResultFormatter_1.DeployAsyncResultFormatter(this.logger, this.ux, formatterOptions, this.asyncDeployResult);
        }
        else {
            formatter = new deployResultFormatter_1.DeployResultFormatter(this.logger, this.ux, formatterOptions, this.deployResult);
        }
        // Only display results to console when JSON flag is unset.
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
    async deployRecentValidation() {
        const conn = this.org.getConnection();
        const id = this.getFlag('validateddeployrequestid');
        const response = await conn.deployRecentValidation({ id, rest: this.isRest });
        // This is the deploy ID of the deployRecentValidation response, not
        // the already validated deploy ID (i.e., validateddeployrequestid).
        let validatedDeployId;
        if ((0, ts_types_1.isString)(response)) {
            // SOAP API
            validatedDeployId = response;
        }
        else {
            // REST API
            validatedDeployId = response.id;
        }
        this.updateDeployId(validatedDeployId);
        return this.isAsync ? this.report(validatedDeployId) : this.poll(validatedDeployId);
    }
}
exports.Deploy = Deploy;
Deploy.description = messages.getMessage('description');
Deploy.examples = messages.getMessage('examples').split(os.EOL);
Deploy.requiresProject = true;
Deploy.requiresUsername = true;
Deploy.flagsConfig = {
    checkonly: command_1.flags.boolean({
        char: 'c',
        description: messages.getMessage('flags.checkonly'),
        longDescription: messages.getMessage('flagsLong.checkonly'),
    }),
    soapdeploy: command_1.flags.boolean({
        default: false,
        description: messages.getMessage('flags.soapDeploy'),
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        default: kit_1.Duration.minutes(Deploy.DEFAULT_SRC_WAIT_MINUTES),
        min: kit_1.Duration.minutes(0),
        description: messages.getMessage('flags.wait'),
        longDescription: messages.getMessage('flagsLong.wait'),
    }),
    testlevel: command_1.flags.enum({
        char: 'l',
        description: messages.getMessage('flags.testLevel'),
        longDescription: messages.getMessage('flagsLong.testLevel'),
        options: ['NoTestRun', 'RunSpecifiedTests', 'RunLocalTests', 'RunAllTestsInOrg'],
        default: 'NoTestRun',
    }),
    runtests: command_1.flags.array({
        char: 'r',
        description: messages.getMessage('flags.runTests'),
        longDescription: messages.getMessage('flagsLong.runTests'),
        default: [],
    }),
    ignoreerrors: command_1.flags.boolean({
        char: 'o',
        description: messages.getMessage('flags.ignoreErrors'),
        longDescription: messages.getMessage('flagsLong.ignoreErrors'),
    }),
    ignorewarnings: command_1.flags.boolean({
        char: 'g',
        description: messages.getMessage('flags.ignoreWarnings'),
        longDescription: messages.getMessage('flagsLong.ignoreWarnings'),
    }),
    validateddeployrequestid: command_1.flags.id({
        char: 'q',
        description: messages.getMessage('flags.validateDeployRequestId'),
        longDescription: messages.getMessage('flagsLong.validateDeployRequestId'),
        exclusive: [
            'manifest',
            'metadata',
            'sourcepath',
            'checkonly',
            'testlevel',
            'runtests',
            'ignoreerrors',
            'ignorewarnings',
        ],
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('flags.verbose'),
    }),
    metadata: command_1.flags.array({
        char: 'm',
        description: messages.getMessage('flags.metadata'),
        longDescription: messages.getMessage('flagsLong.metadata'),
        exclusive: ['manifest', 'sourcepath'],
    }),
    sourcepath: command_1.flags.array({
        char: 'p',
        description: messages.getMessage('flags.sourcePath'),
        longDescription: messages.getMessage('flagsLong.sourcePath'),
        exclusive: ['manifest', 'metadata'],
    }),
    manifest: command_1.flags.filepath({
        char: 'x',
        description: messages.getMessage('flags.manifest'),
        longDescription: messages.getMessage('flagsLong.manifest'),
        exclusive: ['metadata', 'sourcepath'],
    }),
    predestructivechanges: command_1.flags.filepath({
        description: messages.getMessage('flags.predestructivechanges'),
        dependsOn: ['manifest'],
    }),
    postdestructivechanges: command_1.flags.filepath({
        description: messages.getMessage('flags.postdestructivechanges'),
        dependsOn: ['manifest'],
    }),
};
//# sourceMappingURL=deploy.js.map