"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Report = void 0;
const os = require("os");
const core_1 = require("@salesforce/core");
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const deployCommand_1 = require("../../../../deployCommand");
const deployReportResultFormatter_1 = require("../../../../formatters/deployReportResultFormatter");
const componentSetBuilder_1 = require("../../../../componentSetBuilder");
const deployProgressBarFormatter_1 = require("../../../../formatters/deployProgressBarFormatter");
const deployProgressStatusFormatter_1 = require("../../../../formatters/deployProgressStatusFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'report');
class Report extends deployCommand_1.DeployCommand {
    async run() {
        await this.doReport();
        this.resolveSuccess();
        return this.formatResult();
    }
    /**
     * This method is here to provide a workaround to stubbing a constructor in the tests.
     *
     * @param id
     */
    createDeploy(id) {
        return new source_deploy_retrieve_1.MetadataApiDeploy({ usernameOrConnection: this.org.getUsername(), id });
    }
    async doReport() {
        const deployId = this.resolveDeployId(this.getFlag('jobid'));
        // If the verbose flag is set, AND the command was executed from within
        // an SFDX project, we need to build a ComponentSet so we have mapped
        // source file output.
        if (this.getFlag('verbose')) {
            let sourcepath;
            try {
                this.project = await core_1.SfdxProject.resolve();
                sourcepath = this.project.getUniquePackageDirectories().map((pDir) => pDir.fullPath);
            }
            catch (err) {
                // ignore the error. this was just to get improved command output.
            }
            this.componentSet = await componentSetBuilder_1.ComponentSetBuilder.build({ sourcepath });
        }
        const waitDuration = this.getFlag('wait');
        const deploy = this.createDeploy(deployId);
        if (!this.isJsonOutput()) {
            const progressFormatter = kit_1.env.getBoolean('SFDX_USE_PROGRESS_BAR', true)
                ? new deployProgressBarFormatter_1.DeployProgressBarFormatter(this.logger, this.ux)
                : new deployProgressStatusFormatter_1.DeployProgressStatusFormatter(this.logger, this.ux);
            progressFormatter.progress(deploy);
        }
        await deploy.pollStatus(500, waitDuration.seconds);
        this.deployResult = await this.report(deployId);
    }
    // No-op implementation since any DeployResult status would be a success.
    // The only time this command would report an error is if it failed
    // flag parsing or some error during the request, and those are captured
    // by the command framework.
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    resolveSuccess() { }
    formatResult() {
        const formatterOptions = {
            verbose: this.getFlag('verbose', false),
        };
        const formatter = new deployReportResultFormatter_1.DeployReportResultFormatter(this.logger, this.ux, formatterOptions, this.deployResult);
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.Report = Report;
Report.description = messages.getMessage('description');
Report.examples = messages.getMessage('examples').split(os.EOL);
Report.requiresUsername = true;
Report.flagsConfig = {
    wait: command_1.flags.minutes({
        char: 'w',
        default: kit_1.Duration.minutes(deployCommand_1.DeployCommand.DEFAULT_SRC_WAIT_MINUTES),
        min: kit_1.Duration.minutes(1),
        description: messages.getMessage('flags.wait'),
        longDescription: messages.getMessage('flagsLong.wait'),
    }),
    jobid: command_1.flags.id({
        char: 'i',
        description: messages.getMessage('flags.jobid'),
        longDescription: messages.getMessage('flagsLong.jobid'),
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('flags.verbose'),
    }),
};
//# sourceMappingURL=report.js.map