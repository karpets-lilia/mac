"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Delete = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const fs = require("fs");
const prompt_1 = require("cli-ux/lib/prompt");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const deployCommand_1 = require("../../../deployCommand");
const componentSetBuilder_1 = require("../../../componentSetBuilder");
const deleteResultFormatter_1 = require("../../../formatters/deleteResultFormatter");
const deployProgressBarFormatter_1 = require("../../../formatters/deployProgressBarFormatter");
const deployProgressStatusFormatter_1 = require("../../../formatters/deployProgressStatusFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'delete');
class Delete extends deployCommand_1.DeployCommand {
    constructor() {
        super(...arguments);
        this.xorFlags = ['metadata', 'sourcepath'];
        this.lifecycleEventNames = ['predeploy', 'postdeploy'];
        this.isRest = false;
        this.aborted = false;
        this.updateDeployId = (0, kit_1.once)((id) => {
            this.displayDeployId(id);
            this.setStash(id);
        });
    }
    async run() {
        await this.delete();
        this.resolveSuccess();
        const result = this.formatResult();
        // The DeleteResultFormatter will use SDR and scan the directory, if the files have been deleted, it will throw an error
        // so we'll delete the files locally now
        this.deleteFilesLocally();
        return result;
    }
    async delete() {
        this.deleteResultFormatter = new deleteResultFormatter_1.DeleteResultFormatter(this.logger, this.ux, {});
        // verify that the user defined one of: metadata, sourcepath
        this.validateFlags();
        this.componentSet = await componentSetBuilder_1.ComponentSetBuilder.build({
            apiversion: this.getFlag('apiversion'),
            sourceapiversion: await this.getSourceApiVersion(),
            sourcepath: this.getFlag('sourcepath'),
            metadata: this.flags.metadata && {
                metadataEntries: this.getFlag('metadata'),
                directoryPaths: this.getPackageDirs(),
            },
        });
        this.components = this.componentSet.toArray();
        if (!this.components.length) {
            // if we didn't find any components to delete, let the user know and exit
            this.deleteResultFormatter.displayNoResultsFound();
            return;
        }
        // create a new ComponentSet and mark everything for deletion
        const cs = new source_deploy_retrieve_1.ComponentSet([]);
        this.components.map((component) => {
            if (component instanceof source_deploy_retrieve_1.SourceComponent) {
                cs.add(component, source_deploy_retrieve_1.DestructiveChangesType.POST);
            }
            else {
                // a remote-only delete
                cs.add(new source_deploy_retrieve_1.SourceComponent({ name: component.fullName, type: component.type }), source_deploy_retrieve_1.DestructiveChangesType.POST);
            }
        });
        this.componentSet = cs;
        this.aborted = !(await this.handlePrompt());
        if (this.aborted)
            return;
        // fire predeploy event for the delete
        await this.lifecycle.emit('predeploy', this.components);
        this.isRest = await this.isRestDeploy();
        this.ux.log(`*** Deleting with ${this.isRest ? 'REST' : 'SOAP'} API ***`);
        const deploy = await this.componentSet.deploy({
            usernameOrConnection: this.org.getUsername(),
            apiOptions: {
                rest: this.isRest,
                checkOnly: this.getFlag('checkonly', false),
                testLevel: this.getFlag('testlevel'),
            },
        });
        this.updateDeployId(deploy.id);
        if (!this.isJsonOutput()) {
            const progressFormatter = kit_1.env.getBoolean('SFDX_USE_PROGRESS_BAR', true)
                ? new deployProgressBarFormatter_1.DeployProgressBarFormatter(this.logger, this.ux)
                : new deployProgressStatusFormatter_1.DeployProgressStatusFormatter(this.logger, this.ux);
            progressFormatter.progress(deploy);
        }
        this.deployResult = await deploy.pollStatus(500, this.getFlag('wait').seconds);
        await this.lifecycle.emit('postdeploy', this.deployResult);
    }
    /**
     * Checks the response status to determine whether the delete was successful.
     */
    resolveSuccess() {
        const status = (0, ts_types_1.getString)(this.deployResult, 'response.status');
        if (status !== source_deploy_retrieve_1.RequestStatus.Succeeded && !this.aborted) {
            this.setExitCode(1);
        }
    }
    formatResult() {
        const formatterOptions = {
            verbose: this.getFlag('verbose', false),
        };
        this.deleteResultFormatter = new deleteResultFormatter_1.DeleteResultFormatter(this.logger, this.ux, formatterOptions, this.deployResult);
        // Only display results to console when JSON flag is unset.
        if (!this.isJsonOutput()) {
            this.deleteResultFormatter.display();
        }
        return this.deleteResultFormatter.getJson();
    }
    deleteFilesLocally() {
        if (!this.getFlag('checkonly') && (0, ts_types_1.getString)(this.deployResult, 'response.status') === 'Succeeded') {
            this.components.map((component) => {
                // delete the content and/or the xml of the components
                if (component.content) {
                    const stats = fs.lstatSync(component.content);
                    if (stats.isDirectory()) {
                        fs.rmdirSync(component.content, { recursive: true });
                    }
                    else {
                        fs.unlinkSync(component.content);
                    }
                }
                if (component.xml) {
                    fs.unlinkSync(component.xml);
                }
            });
        }
    }
    async handlePrompt() {
        if (!this.getFlag('noprompt')) {
            const remote = [];
            const local = [];
            const message = [];
            this.components.flatMap((component) => {
                if (component instanceof source_deploy_retrieve_1.SourceComponent) {
                    local.push(component.xml, ...component.walkContent());
                }
                else {
                    // remote only metadata
                    remote.push(`${component.type.name}:${component.fullName}`);
                }
            });
            if (remote.length) {
                message.push(messages.getMessage('remotePrompt', [[...new Set(remote)].join('\n')]));
            }
            if (local.length) {
                if (message.length) {
                    // add a whitespace between remote and local
                    message.push('\n');
                }
                message.push('\n', messages.getMessage('localPrompt', [[...new Set(local)].join('\n')]));
            }
            message.push(messages.getMessage('areYouSure'));
            return (0, prompt_1.confirm)(message.join(''));
        }
        return true;
    }
}
exports.Delete = Delete;
Delete.description = messages.getMessage('description');
Delete.examples = messages.getMessage('examples').split(os.EOL);
Delete.requiresProject = true;
Delete.requiresUsername = true;
Delete.flagsConfig = {
    checkonly: command_1.flags.boolean({
        char: 'c',
        description: messages.getMessage('flags.checkonly'),
        longDescription: messages.getMessage('flagsLong.checkonly'),
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        default: kit_1.Duration.minutes(Delete.DEFAULT_SRC_WAIT_MINUTES),
        min: kit_1.Duration.minutes(1),
        description: messages.getMessage('flags.wait'),
        longDescription: messages.getMessage('flagsLong.wait'),
    }),
    testlevel: command_1.flags.enum({
        char: 'l',
        description: messages.getMessage('flags.testLevel'),
        longDescription: messages.getMessage('flagsLong.testLevel'),
        options: ['NoTestRun', 'RunLocalTests', 'RunAllTestsInOrg'],
        default: 'NoTestRun',
    }),
    noprompt: command_1.flags.boolean({
        char: 'r',
        description: messages.getMessage('flags.noprompt'),
    }),
    metadata: command_1.flags.array({
        char: 'm',
        description: messages.getMessage('flags.metadata'),
        longDescription: messages.getMessage('flagsLong.metadata'),
        exclusive: ['manifest', 'sourcepath'],
    }),
    sourcepath: command_1.flags.array({
        char: 'p',
        description: messages.getMessage('flags.sourcepath'),
        longDescription: messages.getMessage('flagsLong.sourcepath'),
        exclusive: ['manifest', 'metadata'],
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('flags.verbose'),
    }),
};
//# sourceMappingURL=delete.js.map