"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployCommand = void 0;
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const sourceCommand_1 = require("./sourceCommand");
class DeployCommand extends sourceCommand_1.SourceCommand {
    constructor() {
        super(...arguments);
        this.displayDeployId = (0, kit_1.once)((id) => {
            if (!this.isJsonOutput()) {
                this.ux.log(`Deploy ID: ${id}`);
            }
        });
    }
    /**
     * Request a report of an in-progess or completed deployment.
     *
     * @param id the Deploy ID of a deployment request
     * @returns DeployResult
     */
    async report(id) {
        const deployId = this.resolveDeployId(id);
        this.displayDeployId(deployId);
        const res = await this.org.getConnection().metadata.checkDeployStatus(deployId, true);
        const deployStatus = res;
        const componentSet = this.componentSet || new source_deploy_retrieve_1.ComponentSet();
        return new source_deploy_retrieve_1.DeployResult(deployStatus, componentSet);
    }
    setStash(deployId) {
        const file = this.getStash();
        this.logger.debug(`Stashing deploy ID: ${deployId} in ${file.getPath()}`);
        file.writeSync({ [DeployCommand.STASH_KEY]: { jobid: deployId } });
    }
    resolveDeployId(id) {
        if (id) {
            return id;
        }
        else {
            try {
                const stash = this.getStash();
                stash.readSync(true);
                const deployId = (0, ts_types_1.asString)(stash.get(DeployCommand.STASH_KEY).jobid);
                this.logger.debug(`Using deploy ID: ${deployId} from ${stash.getPath()}`);
                return deployId;
            }
            catch (err) {
                const error = err;
                if (error.code === 'ENOENT') {
                    throw core_1.SfdxError.create('@salesforce/plugin-source', 'deploy', 'MissingDeployId');
                }
                throw core_1.SfdxError.wrap(error);
            }
        }
    }
    // REST is the default unless:
    //   1. SOAP is specified with the soapdeploy flag on the command
    //   2. The restDeploy SFDX config setting is explicitly false.
    async isRestDeploy() {
        if ((0, ts_types_1.getBoolean)(this.flags, 'soapdeploy') === true) {
            this.logger.debug('soapdeploy flag === true.  Using SOAP');
            return false;
        }
        const aggregator = await core_1.ConfigAggregator.create();
        const restDeployConfig = aggregator.getPropertyValue('restDeploy');
        // aggregator property values are returned as strings
        if (restDeployConfig === 'false') {
            this.logger.debug('restDeploy SFDX config === false.  Using SOAP');
            return false;
        }
        else if (restDeployConfig === 'true') {
            this.logger.debug('restDeploy SFDX config === true.  Using REST');
            return true;
        }
        else {
            this.logger.debug('soapdeploy flag unset. restDeploy SFDX config unset.  Defaulting to SOAP');
        }
        return false;
    }
    async poll(deployId, options) {
        var _a, _b;
        const defaultOptions = {
            frequency: (_a = options === null || options === void 0 ? void 0 : options.frequency) !== null && _a !== void 0 ? _a : kit_1.Duration.seconds(1),
            timeout: (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : this.flags.wait,
            poll: async () => {
                const deployResult = await this.report(deployId);
                return {
                    completed: (0, ts_types_1.getBoolean)(deployResult, 'response.done'),
                    payload: deployResult,
                };
            },
        };
        const pollingOptions = { ...defaultOptions, ...options };
        const pollingClient = await core_1.PollingClient.create(pollingOptions);
        return pollingClient.subscribe();
    }
    getStash() {
        return new core_1.ConfigFile({ isGlobal: true, filename: 'stash.json' });
    }
}
exports.DeployCommand = DeployCommand;
DeployCommand.STASH_KEY = 'SOURCE_DEPLOY';
//# sourceMappingURL=deployCommand.js.map