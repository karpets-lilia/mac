"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const source_tracking_1 = require("@salesforce/source-tracking");
const statusFormatter_1 = require("../../../../formatters/statusFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'status');
class Status extends command_1.SfdxCommand {
    constructor() {
        super(...arguments);
        this.results = new Array();
        this.localAdds = [];
    }
    async run() {
        (0, source_tracking_1.throwIfInvalid)({
            org: this.org,
            projectPath: this.project.getPath(),
            toValidate: 'plugin-source',
            command: (0, source_tracking_1.replaceRenamedCommands)('force:source:status'),
        });
        const wantsLocal = this.flags.local || (!this.flags.remote && !this.flags.local);
        const wantsRemote = this.flags.remote || (!this.flags.remote && !this.flags.local);
        this.logger.debug(`project is ${this.project.getPath()} and pkgDirs are ${this.project
            .getPackageDirectories()
            .map((dir) => dir.path)
            .join(',')}`);
        const tracking = await source_tracking_1.SourceTracking.create({
            org: this.org,
            project: this.project,
            apiVersion: this.flags.apiversion,
        });
        const stlStatusResult = await tracking.getStatus({ local: wantsLocal, remote: wantsRemote });
        this.results = stlStatusResult.map((result) => resultConverter(result));
        return this.formatResult();
    }
    formatResult() {
        const formatter = new statusFormatter_1.StatusFormatter(this.logger, this.ux, {}, this.results);
        if (!this.flags.json) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.default = Status;
Status.description = messages.getMessage('description');
Status.examples = (0, source_tracking_1.replaceRenamedCommands)(messages.getMessage('examples')).split(os.EOL);
Status.flagsConfig = {
    local: command_1.flags.boolean({
        char: 'l',
        description: messages.getMessage('flags.local'),
        longDescription: messages.getMessage('flags.localLong'),
        exclusive: ['remote'],
    }),
    remote: command_1.flags.boolean({
        char: 'r',
        description: messages.getMessage('flags.remote'),
        longDescription: messages.getMessage('flags.remoteLong'),
        exclusive: ['local'],
    }),
};
Status.requiresUsername = true;
Status.requiresProject = true;
/**
 * STL provides a more useful json output.
 * This function makes it consistent with the Status command's json.
 */
const resultConverter = (input) => {
    const { fullName, type, ignored, filePath, conflict } = input;
    const origin = originMap.get(input.origin);
    const actualState = stateMap.get(input.state);
    return {
        fullName,
        type,
        // this string became the place to store information.
        // The JSON now breaks out that info but preserves this property for backward compatibility
        state: `${origin} ${actualState}${conflict ? ' (Conflict)' : ''}`,
        ignored,
        filePath,
        origin,
        actualState,
        conflict,
    };
};
const originMap = new Map([
    ['local', 'Local'],
    ['remote', 'Remote'],
]);
const stateMap = new Map([
    ['delete', 'Deleted'],
    ['add', 'Add'],
    ['modify', 'Changed'],
    ['nondelete', 'Changed'],
]);
//# sourceMappingURL=status.js.map