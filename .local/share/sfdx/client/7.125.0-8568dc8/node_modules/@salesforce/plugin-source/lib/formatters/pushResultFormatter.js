"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PushResultFormatter = void 0;
const chalk = require("chalk");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const resultFormatter_1 = require("./resultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'push');
class PushResultFormatter extends resultFormatter_1.ResultFormatter {
    constructor(logger, ux, options, result) {
        super(logger, ux, options);
        this.result = result;
        this.fileResponses = (result === null || result === void 0 ? void 0 : result.getFileResponses) ? result.getFileResponses() : [];
    }
    /**
     * Get the JSON output from the DeployResult.
     *
     * @returns a JSON formatted result matching the provided type.
     */
    getJson() {
        // quiet returns only failures
        const toReturn = this.isQuiet()
            ? this.fileResponses.filter((fileResponse) => fileResponse.state === source_deploy_retrieve_1.ComponentStatus.Failed)
            : this.fileResponses;
        return toReturn.map(({ state, fullName, type, filePath }) => ({ state, fullName, type, filePath }));
    }
    /**
     * Displays deploy results in human readable format.  Output can vary based on:
     *
     * 1. Verbose option
     * 3. Checkonly deploy (checkonly=true)
     * 4. Deploy with test results
     * 5. Canceled status
     */
    display() {
        this.displaySuccesses();
        this.displayFailures();
        // Throw a DeployFailed error unless the deployment was successful.
        if (!this.isSuccess()) {
            throw new core_1.SfdxError(messages.getMessage('sourcepushFailed'), 'PushFailed');
        }
    }
    hasStatus(status) {
        return (0, ts_types_1.getString)(this.result, 'response.status') === status;
    }
    displaySuccesses() {
        var _a;
        if (this.isQuiet()) {
            return;
        }
        if (this.isSuccess() && ((_a = this.fileResponses) === null || _a === void 0 ? void 0 : _a.length)) {
            const successes = this.fileResponses.filter((f) => f.state !== 'Failed');
            if (!successes.length) {
                return;
            }
            this.sortFileResponses(successes);
            this.asRelativePaths(successes);
            this.ux.log('');
            this.ux.styledHeader(chalk.blue('Pushed Source'));
            this.ux.table(successes, {
                columns: [
                    { key: 'state', label: 'STATE' },
                    { key: 'fullName', label: 'FULL NAME' },
                    { key: 'type', label: 'TYPE' },
                    { key: 'filePath', label: 'PROJECT PATH' },
                ],
            });
        }
    }
    displayFailures() {
        var _a, _b, _c, _d;
        if (this.hasStatus(source_deploy_retrieve_1.RequestStatus.Failed)) {
            const failures = [];
            const fileResponseFailures = new Map();
            if ((_a = this.fileResponses) === null || _a === void 0 ? void 0 : _a.length) {
                const fileResponses = [];
                this.fileResponses
                    .filter((f) => f.state === 'Failed')
                    .map((f) => {
                    fileResponses.push(f);
                    fileResponseFailures.set(`${f.type}#${f.fullName}`, f.error);
                });
                this.sortFileResponses(fileResponses);
                this.asRelativePaths(fileResponses);
                failures.push(...fileResponses);
            }
            const deployMessages = (0, resultFormatter_1.toArray)((_d = (_c = (_b = this.result) === null || _b === void 0 ? void 0 : _b.response) === null || _c === void 0 ? void 0 : _c.details) === null || _d === void 0 ? void 0 : _d.componentFailures);
            if (deployMessages.length > failures.length) {
                // if there's additional failures in the API response, find the failure and add it to the output
                deployMessages.map((deployMessage) => {
                    if (!fileResponseFailures.has(`${deployMessage.componentType}#${deployMessage.fullName}`)) {
                        // duplicate the problem message to the error property for displaying in the table
                        failures.push(Object.assign(deployMessage, { error: deployMessage.problem }));
                    }
                });
            }
            this.ux.log('');
            this.ux.styledHeader(chalk.red(`Component Failures [${failures.length}]`));
            this.ux.table(failures, {
                columns: [
                    { key: 'problemType', label: 'Type' },
                    { key: 'fullName', label: 'Name' },
                    { key: 'error', label: 'Problem' },
                ],
            });
            this.ux.log('');
        }
    }
}
exports.PushResultFormatter = PushResultFormatter;
//# sourceMappingURL=pushResultFormatter.js.map