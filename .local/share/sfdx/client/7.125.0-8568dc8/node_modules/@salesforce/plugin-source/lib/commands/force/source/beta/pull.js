"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const source_tracking_1 = require("@salesforce/source-tracking");
const conflicts_1 = require("../../../../formatters/conflicts");
const sourceCommand_1 = require("../../../../sourceCommand");
const pullFormatter_1 = require("../../../../formatters/pullFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'pull');
class Pull extends sourceCommand_1.SourceCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['preretrieve', 'postretrieve'];
    }
    async run() {
        await this.preChecks();
        await this.retrieve();
        // do not parallelize delete and retrieve...we only get to delete IF retrieve was successful
        await this.doDeletes(); // deletes includes its tracking file operations
        await this.updateTrackingFilesWithRetrieve();
        this.ux.stopSpinner();
        return this.formatResult();
    }
    async preChecks() {
        // checks the source tracking file version and throws if they're toolbelt's old version
        (0, source_tracking_1.throwIfInvalid)({
            org: this.org,
            projectPath: this.project.getPath(),
            toValidate: 'plugin-source',
            command: (0, source_tracking_1.replaceRenamedCommands)('force:source:pull'),
        });
        this.ux.startSpinner('Loading source tracking information');
        this.tracking = await source_tracking_1.SourceTracking.create({
            org: this.org,
            project: this.project,
        });
        await this.tracking.ensureRemoteTracking(true);
        if (!this.flags.forceoverwrite) {
            this.ux.setSpinnerStatus('Checking for conflicts');
            (0, conflicts_1.processConflicts)(await this.tracking.getConflicts(), this.ux, messages.getMessage('sourceConflictDetected'));
        }
    }
    async doDeletes() {
        this.ux.setSpinnerStatus('Checking for deletes from the org and updating source tracking files');
        const changesToDelete = await this.tracking.getChanges({
            origin: 'remote',
            state: 'delete',
            format: 'SourceComponent',
        });
        this.deleteFileResponses = await this.tracking.deleteFilesAndUpdateTracking(changesToDelete);
    }
    async updateTrackingFilesWithRetrieve() {
        this.ux.setSpinnerStatus('Updating source tracking files');
        // might not exist if we exited from retrieve early
        if (!this.retrieveResult) {
            return;
        }
        const successes = this.retrieveResult
            .getFileResponses()
            .filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Failed);
        await Promise.all([
            // commit the local file successes that the retrieve modified
            this.tracking.updateLocalTracking({
                files: successes.map((fileResponse) => fileResponse.filePath).filter(Boolean),
            }),
            this.tracking.updateRemoteTracking(successes.map(({ state, fullName, type, filePath }) => ({ state, fullName, type, filePath })), true // skip polling because it's a pull
            ),
        ]);
    }
    async retrieve() {
        const componentSet = new source_deploy_retrieve_1.ComponentSet();
        (await this.tracking.getChanges({
            origin: 'remote',
            state: 'nondelete',
            format: 'ChangeResult',
        })).map((component) => {
            if (component.type && component.name) {
                componentSet.add({
                    type: component.type,
                    fullName: component.name,
                });
            }
        });
        if (componentSet.size === 0) {
            return;
        }
        componentSet.sourceApiVersion = await this.getSourceApiVersion();
        if (this.getFlag('apiversion')) {
            componentSet.apiVersion = this.getFlag('apiversion');
        }
        const mdapiRetrieve = await componentSet.retrieve({
            usernameOrConnection: this.org.getUsername(),
            merge: true,
            output: this.project.getDefaultPackage().path,
        });
        this.ux.setSpinnerStatus('Retrieving metadata from the org');
        // assume: remote deletes that get deleted locally don't fire hooks?
        await this.lifecycle.emit('preretrieve', componentSet.toArray());
        this.retrieveResult = await mdapiRetrieve.pollStatus(1000, this.getFlag('wait').seconds);
        // Assume: remote deletes that get deleted locally don't fire hooks.
        await this.lifecycle.emit('postretrieve', this.retrieveResult.getFileResponses());
    }
    resolveSuccess() {
        // there might not be a retrieveResult if we don't have anything to retrieve
        if (this.retrieveResult && this.retrieveResult.response.status !== source_deploy_retrieve_1.RequestStatus.Succeeded) {
            this.setExitCode(1);
        }
    }
    formatResult() {
        const formatterOptions = {
            verbose: this.getFlag('verbose', false),
        };
        const formatter = new pullFormatter_1.PullResultFormatter(this.logger, this.ux, formatterOptions, this.retrieveResult, this.deleteFileResponses);
        // Only display results to console when JSON flag is unset.
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.default = Pull;
Pull.description = messages.getMessage('description');
Pull.help = messages.getMessage('help');
Pull.flagsConfig = {
    forceoverwrite: command_1.flags.boolean({
        char: 'f',
        description: messages.getMessage('flags.forceoverwrite'),
    }),
    // TODO: use shared flags from plugin-source
    wait: command_1.flags.minutes({
        char: 'w',
        default: kit_1.Duration.minutes(33),
        min: kit_1.Duration.minutes(0),
        description: messages.getMessage('flags.waitLong'),
    }),
};
Pull.requiresUsername = true;
Pull.requiresProject = true;
//# sourceMappingURL=pull.js.map