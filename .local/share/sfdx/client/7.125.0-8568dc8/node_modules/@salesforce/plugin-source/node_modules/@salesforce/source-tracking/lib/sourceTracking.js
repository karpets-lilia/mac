"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceTracking = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path = require("path");
const os_1 = require("os");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const remoteSourceTrackingService_1 = require("./shared/remoteSourceTrackingService");
const localShadowRepo_1 = require("./shared/localShadowRepo");
const filenamesToVirtualTree_1 = require("./shared/filenamesToVirtualTree");
const guards_1 = require("./shared/guards");
const functions_1 = require("./shared/functions");
/**
 * Manages source tracking files (remote and local)
 *
 * const tracking = await SourceTracking.create({org: this.org, project: this.project});
 *
 */
class SourceTracking extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.orgId = options.org.getOrgId();
        this.username = options.org.getUsername();
        this.projectPath = options.project.getPath();
        this.packagesDirs = options.project.getPackageDirectories();
        this.logger = core_1.Logger.childFromRoot('SourceTracking');
        this.project = options.project;
    }
    async init() {
        // reserved for future use
    }
    async localChangesAsComponentSet() {
        const [projectConfig] = await Promise.all([this.project.resolveProjectConfig(), this.ensureLocalTracking()]);
        const sourceApiVersion = (0, ts_types_1.getString)(projectConfig, 'sourceApiVersion');
        const componentSet = new source_deploy_retrieve_1.ComponentSet();
        if (sourceApiVersion) {
            componentSet.sourceApiVersion = sourceApiVersion;
        }
        const [nonDeletes, deletes] = await Promise.all([
            this.localRepo.getNonDeleteFilenames(),
            this.localRepo.getDeleteFilenames(),
        ]);
        if (nonDeletes.length === 0 && deletes.length === 0) {
            this.logger.debug('no local changes found in source tracking files');
            return componentSet;
        }
        // optimistic resolution...some files may not be possible to resolve
        const resolverForNonDeletes = new source_deploy_retrieve_1.MetadataResolver();
        // we need virtual components for the deletes.
        // TODO: could we use the same for the non-deletes?
        const resolverForDeletes = new source_deploy_retrieve_1.MetadataResolver(undefined, (0, filenamesToVirtualTree_1.filenamesToVirtualTree)(deletes));
        nonDeletes
            .flatMap((filename) => {
            try {
                return resolverForNonDeletes.getComponentsFromPath(filename);
            }
            catch (e) {
                this.logger.warn(`unable to resolve ${filename}`);
                return undefined;
            }
        })
            .filter(guards_1.sourceComponentGuard)
            .map((component) => componentSet.add(component));
        deletes
            .flatMap((filename) => resolverForDeletes.getComponentsFromPath(filename))
            .filter(guards_1.sourceComponentGuard)
            .map((component) => componentSet.add(component, source_deploy_retrieve_1.DestructiveChangesType.POST));
        return componentSet;
    }
    /**
     * Does most of the work for the force:source:status command.
     * Outputs need a bit of massage since this aims to provide nice json.
     *
     * @param local you want local status
     * @param remote you want remote status
     * @returns StatusOutputRow[]
     */
    async getStatus({ local, remote }) {
        let results = [];
        if (local) {
            results = results.concat(await this.getLocalStatusRows());
        }
        if (remote) {
            await this.ensureRemoteTracking(true);
            const [remoteDeletes, remoteModifies] = await Promise.all([
                this.getChanges({ origin: 'remote', state: 'delete', format: 'ChangeResult' }),
                this.getChanges({ origin: 'remote', state: 'nondelete', format: 'ChangeResultWithPaths' }),
            ]);
            results = results.concat((await Promise.all(remoteDeletes.concat(remoteModifies).map((item) => this.remoteChangesToOutputRows(item)))).flat(1));
        }
        if (local && remote) {
            // keys like ApexClass__MyClass.cls
            const conflictFiles = (await this.getConflicts()).flatMap((conflict) => conflict.filenames).filter(guards_1.stringGuard);
            results = results.map((row) => ({
                ...row,
                conflict: !!row.filePath && conflictFiles.includes(row.filePath),
            }));
        }
        return results;
    }
    /**
     * Get metadata changes made locally and in the org.
     *
     * @returns local and remote changed metadata
     *
     */
    async getChanges(options) {
        if ((options === null || options === void 0 ? void 0 : options.origin) === 'local') {
            await this.ensureLocalTracking();
            const filenames = await this.getLocalChangesAsFilenames(options.state);
            if (options.format === 'string') {
                return filenames;
            }
            if (options.format === 'ChangeResult' || options.format === 'ChangeResultWithPaths') {
                return filenames.map((filename) => ({
                    filenames: [filename],
                    origin: 'local',
                }));
            }
            if (options.format === 'SourceComponent') {
                const resolver = options.state === 'delete'
                    ? new source_deploy_retrieve_1.MetadataResolver(undefined, (0, filenamesToVirtualTree_1.filenamesToVirtualTree)(filenames))
                    : new source_deploy_retrieve_1.MetadataResolver();
                return filenames
                    .flatMap((filename) => {
                    try {
                        return resolver.getComponentsFromPath(filename);
                    }
                    catch (e) {
                        this.logger.warn(`unable to resolve ${filename}`);
                        return undefined;
                    }
                })
                    .filter(guards_1.sourceComponentGuard);
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.origin) === 'remote') {
            await this.ensureRemoteTracking();
            const remoteChanges = await this.remoteSourceTrackingService.retrieveUpdates();
            this.logger.debug('remoteChanges', remoteChanges);
            const filteredChanges = remoteChanges.filter(remoteFilterByState[options.state]);
            if (options.format === 'ChangeResult') {
                return filteredChanges.map((change) => (0, remoteSourceTrackingService_1.remoteChangeElementToChangeResult)(change));
            }
            if (options.format === 'ChangeResultWithPaths') {
                return this.populateFilePaths(filteredChanges.map((change) => (0, remoteSourceTrackingService_1.remoteChangeElementToChangeResult)(change)));
            }
            // turn it into a componentSet to resolve filenames
            const remoteChangesAsComponentSet = new source_deploy_retrieve_1.ComponentSet(filteredChanges.map((element) => ({
                type: element === null || element === void 0 ? void 0 : element.type,
                fullName: element === null || element === void 0 ? void 0 : element.name,
            })));
            const matchingLocalSourceComponentsSet = source_deploy_retrieve_1.ComponentSet.fromSource({
                fsPaths: this.packagesDirs.map((dir) => dir.path),
                include: remoteChangesAsComponentSet,
            });
            if (options.format === 'string') {
                return matchingLocalSourceComponentsSet
                    .getSourceComponents()
                    .toArray()
                    .flatMap((component) => [component.xml, ...component.walkContent()].filter((filename) => filename));
            }
            else if (options.format === 'SourceComponent') {
                return matchingLocalSourceComponentsSet.getSourceComponents().toArray();
            }
        }
        throw new Error(`unsupported options: ${JSON.stringify(options)}`);
    }
    /**
     *
     * returns immediately if there are no changesToDelete
     *
     * @param changesToDelete array of SourceComponent
     */
    async deleteFilesAndUpdateTracking(changesToDelete) {
        if (changesToDelete.length === 0) {
            return [];
        }
        const sourceComponentByFileName = new Map();
        changesToDelete.flatMap((component) => [component.xml, ...component.walkContent()]
            .filter((filename) => filename)
            .map((filename) => sourceComponentByFileName.set(filename, component)));
        const filenames = Array.from(sourceComponentByFileName.keys());
        // delete the files
        await Promise.all(filenames.map((filename) => fs.promises.unlink(filename)));
        // update the tracking files.  We're simulating SDR-style fileResponse
        await Promise.all([
            this.updateLocalTracking({ deletedFiles: filenames }),
            this.updateRemoteTracking(changesToDelete.map((component) => ({
                type: component.type.name,
                fullName: component.fullName,
                state: source_deploy_retrieve_1.ComponentStatus.Deleted,
            })), true // skip polling because it's a pull
            ),
        ]);
        return filenames.map((filename) => {
            var _a, _b;
            return ({
                state: 'Deleted',
                filename,
                type: (_a = sourceComponentByFileName.get(filename)) === null || _a === void 0 ? void 0 : _a.type.name,
                fullName: (_b = sourceComponentByFileName.get(filename)) === null || _b === void 0 ? void 0 : _b.fullName,
            });
        });
    }
    /**
     * Update tracking for the options passed.
     *
     * @param options the files to update
     */
    async updateLocalTracking(options) {
        var _a, _b;
        await this.ensureLocalTracking();
        await this.localRepo.commitChanges({
            deployedFiles: (_a = options.files) === null || _a === void 0 ? void 0 : _a.map((file) => this.ensureRelative(file)),
            deletedFiles: (_b = options.deletedFiles) === null || _b === void 0 ? void 0 : _b.map((file) => this.ensureRelative(file)),
        });
    }
    /**
     * Mark remote source tracking files so say that we have received the latest version from the server
     * Optionall skip polling for the SourceMembers to exist on the server and be updated in local files
     */
    async updateRemoteTracking(fileResponses, skipPolling = false) {
        // false to explicitly NOT query until we do the polling
        await this.ensureRemoteTracking(false);
        if (!skipPolling) {
            // poll to make sure we have the updates before syncing the ones from metadataKeys
            await this.remoteSourceTrackingService.pollForSourceTracking(fileResponses);
        }
        await this.remoteSourceTrackingService.syncSpecifiedElements(fileResponses);
    }
    /**
     * If the local tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists.
     * Useful before parallel operations
     */
    async ensureLocalTracking() {
        if (this.localRepo) {
            return;
        }
        this.localRepo = await localShadowRepo_1.ShadowRepo.getInstance({
            orgId: this.orgId,
            projectPath: this.projectPath,
            packageDirs: this.packagesDirs,
        });
        // loads the status from file so that it's cached
        await this.localRepo.getStatus();
    }
    /**
     * If the remote tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists.
     * Useful before parallel operations
     */
    async ensureRemoteTracking(initializeWithQuery = false) {
        if (this.remoteSourceTrackingService) {
            this.logger.debug('ensureRemoteTracking: remote tracking already exists');
            return;
        }
        this.logger.debug('ensureRemoteTracking: remote tracking does not exist yet; getting instance');
        this.remoteSourceTrackingService = await remoteSourceTrackingService_1.RemoteSourceTrackingService.getInstance({
            username: this.username,
            orgId: this.orgId,
        });
        if (initializeWithQuery) {
            await this.remoteSourceTrackingService.retrieveUpdates();
        }
    }
    /**
     * Deletes the local tracking shadowRepo
     * return the list of files that were in it
     */
    async clearLocalTracking() {
        await this.ensureLocalTracking();
        return this.localRepo.delete();
    }
    /**
     * Commits all the local changes so that no changes are present in status
     */
    async resetLocalTracking() {
        await this.ensureLocalTracking();
        const [deletes, nonDeletes] = await Promise.all([
            this.localRepo.getDeleteFilenames(),
            this.localRepo.getNonDeleteFilenames(),
        ]);
        await this.localRepo.commitChanges({
            deletedFiles: deletes,
            deployedFiles: nonDeletes,
            message: 'via resetLocalTracking',
        });
        return [...deletes, ...nonDeletes];
    }
    /**
     * Deletes the remote tracking files
     */
    async clearRemoteTracking() {
        return remoteSourceTrackingService_1.RemoteSourceTrackingService.delete(this.orgId);
    }
    /**
     * Sets the files to max revision so that no changes appear
     */
    async resetRemoteTracking(serverRevision) {
        await this.ensureRemoteTracking();
        const resetMembers = await this.remoteSourceTrackingService.reset(serverRevision);
        return resetMembers.length;
    }
    /**
     * Compares local and remote changes to detect conflicts
     */
    async getConflicts() {
        // we're going to need have both initialized
        await Promise.all([this.ensureRemoteTracking(), this.ensureLocalTracking()]);
        // Strategy: check local changes first (since it'll be faster) to avoid callout
        // early return if either local or remote is empty
        const localChanges = await this.getChanges({
            state: 'nondelete',
            origin: 'local',
            format: 'ChangeResult',
        });
        if (localChanges.length === 0) {
            return [];
        }
        const remoteChanges = await this.getChanges({
            origin: 'remote',
            state: 'nondelete',
            // remote adds won't have a filename, so we ask for it to be resolved
            format: 'ChangeResultWithPaths',
        });
        if (remoteChanges.length === 0) {
            return [];
        }
        // index the remoteChanges by filename
        const fileNameIndex = new Map();
        const metadataKeyIndex = new Map();
        remoteChanges.map((change) => {
            var _a;
            if (change.name && change.type) {
                metadataKeyIndex.set((0, functions_1.getMetadataKey)(change.name, change.type), change);
            }
            (_a = change.filenames) === null || _a === void 0 ? void 0 : _a.map((filename) => {
                fileNameIndex.set(filename, change);
            });
        });
        const conflicts = new Set();
        this.populateTypesAndNames({ elements: localChanges, excludeUnresolvable: true }).map((change) => {
            var _a;
            const metadataKey = (0, functions_1.getMetadataKey)(change.name, change.type);
            // option 1: name and type match
            if (metadataKeyIndex.has(metadataKey)) {
                conflicts.add({ ...metadataKeyIndex.get(metadataKey) });
            }
            else {
                // option 2: some of the filenames match
                (_a = change.filenames) === null || _a === void 0 ? void 0 : _a.map((filename) => {
                    if (fileNameIndex.has(filename)) {
                        conflicts.add({ ...fileNameIndex.get(filename) });
                    }
                });
            }
        });
        // deeply de-dupe
        return Array.from(conflicts);
    }
    /**
     * uses SDR to translate remote metadata records into local file paths (which only typically have the filename).
     *
     * @input elements: ChangeResult[]
     * @input excludeUnresolvables: boolean Filter out components where you can't get the name and type (that is, it's probably not a valid source component)
     * @input resolveDeleted: constructs a virtualTree instead of the actual filesystem--useful when the files no longer exist
     * @input useFsForceIgnore: (default behavior) use forceIgnore from the filesystem.  If false, uses the base forceIgnore from SDR
     */
    populateTypesAndNames({ elements, excludeUnresolvable = false, resolveDeleted = false, useFsForceIgnore = true, }) {
        if (elements.length === 0) {
            return [];
        }
        this.logger.debug(`populateTypesAndNames for ${elements.length} change elements`);
        const filenames = elements.flatMap((element) => element.filenames).filter(guards_1.stringGuard);
        // component set generated from the filenames on all local changes
        const resolver = new source_deploy_retrieve_1.MetadataResolver(undefined, resolveDeleted ? (0, filenamesToVirtualTree_1.filenamesToVirtualTree)(filenames) : undefined, useFsForceIgnore);
        const sourceComponents = filenames
            .flatMap((filename) => {
            try {
                return resolver.getComponentsFromPath(filename);
            }
            catch (e) {
                this.logger.warn(`unable to resolve ${filename}`);
                return undefined;
            }
        })
            .filter(guards_1.sourceComponentGuard);
        this.logger.debug(` matching SourceComponents have ${sourceComponents.length} items from local`);
        // make it simpler to find things later
        const elementMap = new Map();
        elements.map((element) => {
            var _a;
            (_a = element.filenames) === null || _a === void 0 ? void 0 : _a.map((filename) => {
                elementMap.set(this.ensureRelative(filename), element);
            });
        });
        // iterates the local components and sets their filenames
        sourceComponents.map((matchingComponent) => {
            var _a;
            if ((matchingComponent === null || matchingComponent === void 0 ? void 0 : matchingComponent.fullName) && (matchingComponent === null || matchingComponent === void 0 ? void 0 : matchingComponent.type.name)) {
                const filenamesFromMatchingComponent = [matchingComponent.xml, ...matchingComponent.walkContent()];
                // Set the ignored status at the component level so it can apply to all its files, some of which may not match the ignoreFile (ex: ApexClass)
                this.forceIgnore = (_a = this.forceIgnore) !== null && _a !== void 0 ? _a : source_deploy_retrieve_1.ForceIgnore.findAndCreate(this.project.getDefaultPackage().path);
                const ignored = filenamesFromMatchingComponent
                    .filter(guards_1.stringGuard)
                    .filter((filename) => !filename.includes('__tests__'))
                    .some((filename) => this.forceIgnore.denies(filename));
                filenamesFromMatchingComponent.map((filename) => {
                    if (filename && elementMap.has(filename)) {
                        // add the type/name from the componentSet onto the element
                        elementMap.set(filename, {
                            origin: 'remote',
                            ...elementMap.get(filename),
                            type: matchingComponent.type.name,
                            name: matchingComponent.fullName,
                            ignored,
                        });
                    }
                });
            }
        });
        return excludeUnresolvable
            ? Array.from(new Set(elementMap.values())).filter((changeResult) => changeResult.name && changeResult.type)
            : Array.from(new Set(elementMap.values()));
    }
    async getLocalStatusRows() {
        await this.ensureLocalTracking();
        let results = [];
        const localDeletes = this.populateTypesAndNames({
            elements: await this.getChanges({ origin: 'local', state: 'delete', format: 'ChangeResult' }),
            excludeUnresolvable: true,
            resolveDeleted: true,
            useFsForceIgnore: false,
        });
        const localAdds = this.populateTypesAndNames({
            elements: await this.getChanges({ origin: 'local', state: 'add', format: 'ChangeResult' }),
            excludeUnresolvable: true,
            useFsForceIgnore: false,
        });
        const localModifies = this.populateTypesAndNames({
            elements: await this.getChanges({ origin: 'local', state: 'modify', format: 'ChangeResult' }),
            excludeUnresolvable: true,
            useFsForceIgnore: false,
        });
        results = results.concat(localAdds.flatMap((item) => this.localChangesToOutputRow(item, 'add')), localModifies.flatMap((item) => this.localChangesToOutputRow(item, 'modify')), localDeletes.flatMap((item) => this.localChangesToOutputRow(item, 'delete')));
        return results;
    }
    /**
     * uses SDR to translate remote metadata records into local file paths
     */
    populateFilePaths(elements) {
        if (elements.length === 0) {
            return [];
        }
        this.logger.debug('populateFilePaths for change elements', elements);
        // component set generated from an array of ComponentLike from all the remote changes
        const remoteChangesAsComponentLike = elements.map((element) => ({
            type: element === null || element === void 0 ? void 0 : element.type,
            fullName: element === null || element === void 0 ? void 0 : element.name,
        }));
        const remoteChangesAsComponentSet = new source_deploy_retrieve_1.ComponentSet(remoteChangesAsComponentLike);
        this.logger.debug(` the generated component set has ${remoteChangesAsComponentSet.size.toString()} items`);
        if (remoteChangesAsComponentSet.size < elements.length) {
            // iterate the elements to see which ones didn't make it into the component set
            throw new Error(`unable to generate complete component set for ${elements
                .filter((element) => !remoteChangesAsComponentSet.has({ type: element === null || element === void 0 ? void 0 : element.type, fullName: element === null || element === void 0 ? void 0 : element.name }))
                .map((element) => `${element.name} (${element.type})`)
                .join(os_1.EOL)}`);
        }
        const matchingLocalSourceComponentsSet = source_deploy_retrieve_1.ComponentSet.fromSource({
            fsPaths: this.packagesDirs.map((dir) => dir.path),
            include: remoteChangesAsComponentSet,
        });
        this.logger.debug(` local source-backed component set has ${matchingLocalSourceComponentsSet.size.toString()} items from remote`);
        // make it simpler to find things later
        const elementMap = new Map();
        elements.map((element) => {
            elementMap.set((0, functions_1.getKeyFromObject)(element), element);
        });
        // iterates the local components and sets their filenames
        for (const matchingComponent of matchingLocalSourceComponentsSet.getSourceComponents().toArray()) {
            if (matchingComponent.fullName && matchingComponent.type.name) {
                this.logger.debug(`${matchingComponent.fullName}|${matchingComponent.type.name} matches ${matchingComponent.xml} and maybe ${matchingComponent.walkContent().toString()}`);
                const key = (0, functions_1.getMetadataKey)(matchingComponent.type.name, matchingComponent.fullName);
                elementMap.set(key, {
                    ...elementMap.get(key),
                    modified: true,
                    origin: 'remote',
                    filenames: [matchingComponent.xml, ...matchingComponent.walkContent()].filter((filename) => filename),
                });
            }
        }
        return Array.from(elementMap.values());
    }
    ensureRelative(filePath) {
        return path.isAbsolute(filePath) ? path.relative(this.projectPath, filePath) : filePath;
    }
    async getLocalChangesAsFilenames(state) {
        if (state === 'modify') {
            return this.localRepo.getModifyFilenames();
        }
        if (state === 'nondelete') {
            return this.localRepo.getNonDeleteFilenames();
        }
        if (state === 'delete') {
            return this.localRepo.getDeleteFilenames();
        }
        if (state === 'add') {
            return this.localRepo.getAddFilenames();
        }
        throw new Error(`unable to get local changes for state ${state}`);
    }
    localChangesToOutputRow(input, localType) {
        var _a, _b, _c;
        this.logger.debug('converting ChangeResult to a row', input);
        const baseObject = {
            type: (_a = input.type) !== null && _a !== void 0 ? _a : '',
            origin: 'local',
            state: localType,
            fullName: (_b = input.name) !== null && _b !== void 0 ? _b : '',
            // ignored property will be set in populateTypesAndNames
            ignored: (_c = input.ignored) !== null && _c !== void 0 ? _c : false,
        };
        if (input.filenames) {
            return input.filenames.map((filename) => ({
                ...baseObject,
                filePath: filename,
                origin: 'local',
            }));
        }
        throw new Error('no filenames found for local ChangeResult');
    }
    // this will eventually have async call to figure out the target file locations for remote changes
    // eslint-disable-next-line @typescript-eslint/require-await
    async remoteChangesToOutputRows(input) {
        var _a, _b, _c, _d;
        this.logger.debug('converting ChangeResult to a row', input);
        this.forceIgnore = (_a = this.forceIgnore) !== null && _a !== void 0 ? _a : source_deploy_retrieve_1.ForceIgnore.findAndCreate(this.project.getDefaultPackage().path);
        const baseObject = {
            type: (_b = input.type) !== null && _b !== void 0 ? _b : '',
            origin: input.origin,
            state: stateFromChangeResult(input),
            fullName: (_c = input.name) !== null && _c !== void 0 ? _c : '',
        };
        // it's easy to check ignores if the filePaths exist locally
        if ((_d = input.filenames) === null || _d === void 0 ? void 0 : _d.length) {
            return input.filenames.map((filename) => ({
                ...baseObject,
                filePath: filename,
                ignored: this.forceIgnore.denies(filename),
            }));
        }
        // when the file doesn't exist locally, there are no filePaths
        // So we can't say whether it's ignored or not
        return [baseObject];
    }
}
exports.SourceTracking = SourceTracking;
const remoteFilterByState = {
    add: (change) => !change.deleted && !change.modified,
    modify: (change) => change.modified === true,
    delete: (change) => change.deleted === true,
    nondelete: (change) => !change.deleted,
};
const stateFromChangeResult = (input) => {
    if (input.deleted) {
        return 'delete';
    }
    if (input.modified) {
        return 'modify';
    }
    return 'add';
};
//# sourceMappingURL=sourceTracking.js.map