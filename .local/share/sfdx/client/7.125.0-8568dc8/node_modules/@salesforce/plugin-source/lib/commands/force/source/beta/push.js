"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const source_tracking_1 = require("@salesforce/source-tracking");
const deployCommand_1 = require("../../../../deployCommand");
const pushResultFormatter_1 = require("../../../../formatters/pushResultFormatter");
const deployProgressBarFormatter_1 = require("../../../../formatters/deployProgressBarFormatter");
const deployProgressStatusFormatter_1 = require("../../../../formatters/deployProgressStatusFormatter");
const conflicts_1 = require("../../../../formatters/conflicts");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'push');
class Push extends deployCommand_1.DeployCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['predeploy', 'postdeploy'];
        this.isRest = false;
    }
    async run() {
        await this.deploy();
        this.resolveSuccess();
        return this.formatResult();
    }
    async deploy() {
        (0, source_tracking_1.throwIfInvalid)({
            org: this.org,
            projectPath: this.project.getPath(),
            toValidate: 'plugin-source',
            command: (0, source_tracking_1.replaceRenamedCommands)('force:source:push'),
        });
        const waitDuration = this.getFlag('wait');
        this.isRest = await this.isRestDeploy();
        const tracking = await source_tracking_1.SourceTracking.create({
            org: this.org,
            project: this.project,
            apiVersion: this.flags.apiversion,
        });
        if (!this.flags.forceoverwrite) {
            (0, conflicts_1.processConflicts)(await tracking.getConflicts(), this.ux, messages.getMessage('conflictMsg'));
        }
        const componentSet = await tracking.localChangesAsComponentSet();
        componentSet.sourceApiVersion = await this.getSourceApiVersion();
        // there might have been components in local tracking, but they might be ignored by SDR or unresolvable.
        // SDR will throw when you try to resolve them, so don't
        if (componentSet.size === 0) {
            this.logger.warn('There are no changes to deploy');
            return;
        }
        // fire predeploy event for sync and async deploys
        await this.lifecycle.emit('predeploy', componentSet.toArray());
        this.ux.log(`*** Pushing with ${this.isRest ? 'REST' : 'SOAP'} API v${componentSet.sourceApiVersion} ***`);
        const deploy = await componentSet.deploy({
            usernameOrConnection: this.org.getUsername(),
            apiOptions: {
                ignoreWarnings: this.getFlag('ignorewarnings', false),
                rest: this.isRest,
                testLevel: 'NoTestRun',
            },
        });
        // we're not print JSON output
        if (!this.isJsonOutput()) {
            const progressFormatter = kit_1.env.getBoolean('SFDX_USE_PROGRESS_BAR', true)
                ? new deployProgressBarFormatter_1.DeployProgressBarFormatter(this.logger, this.ux)
                : new deployProgressStatusFormatter_1.DeployProgressStatusFormatter(this.logger, this.ux);
            progressFormatter.progress(deploy);
        }
        this.deployResult = await deploy.pollStatus(500, waitDuration.seconds);
        const successes = this.deployResult
            .getFileResponses()
            .filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Failed);
        const successNonDeletes = successes.filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Deleted);
        const successDeletes = successes.filter((fileResponse) => fileResponse.state === source_deploy_retrieve_1.ComponentStatus.Deleted);
        if (this.deployResult) {
            // Only fire the postdeploy event when we have results. I.e., not async.
            await this.lifecycle.emit('postdeploy', this.deployResult);
        }
        await Promise.all([
            tracking.updateLocalTracking({
                files: successNonDeletes.map((fileResponse) => fileResponse.filePath),
                deletedFiles: successDeletes.map((fileResponse) => fileResponse.filePath),
            }),
            tracking.updateRemoteTracking(successes),
        ]);
    }
    resolveSuccess() {
        // there might not be a deployResult if we exited early with an empty componentSet
        if (this.deployResult && this.deployResult.response.status !== source_deploy_retrieve_1.RequestStatus.Succeeded) {
            this.setExitCode(1);
        }
    }
    formatResult() {
        if (!this.deployResult) {
            this.ux.log('No results found');
        }
        const formatterOptions = {
            quiet: this.getFlag('quiet', false),
        };
        const formatter = new pushResultFormatter_1.PushResultFormatter(this.logger, this.ux, formatterOptions, this.deployResult);
        // Only display results to console when JSON flag is unset.
        if (!this.isJsonOutput()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.default = Push;
Push.description = messages.getMessage('description');
Push.help = messages.getMessage('help');
Push.flagsConfig = {
    forceoverwrite: command_1.flags.boolean({
        char: 'f',
        description: messages.getMessage('flags.forceoverwrite'),
        longDescription: messages.getMessage('flags.forceoverwriteLong'),
    }),
    // TODO: use shared flags from plugin-source?
    wait: command_1.flags.minutes({
        char: 'w',
        default: kit_1.Duration.minutes(33),
        min: kit_1.Duration.minutes(1),
        description: messages.getMessage('flags.waitLong'),
        longDescription: messages.getMessage('flags.waitLong'),
    }),
    ignorewarnings: command_1.flags.boolean({
        char: 'g',
        description: messages.getMessage('flags.ignorewarnings'),
        longDescription: messages.getMessage('flags.ignorewarningsLong'),
    }),
    quiet: command_1.flags.builtin({
        description: messages.getMessage('flags.quiet'),
    }),
};
Push.requiresUsername = true;
Push.requiresProject = true;
//# sourceMappingURL=push.js.map