"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint-disable no-console */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowRepo = void 0;
const path = require("path");
const os = require("os");
const core_1 = require("@salesforce/core");
const git = require("isomorphic-git");
const gitIgnoreFileName = '.gitignore';
const stashedGitIgnoreFileName = '.BAK.gitignore';
/**
 * returns the full path to where we store the shadow repo
 */
const getGitDir = (orgId, projectPath) => {
    return path.join(projectPath, '.sfdx', 'orgs', orgId, 'localSourceTracking');
};
// filenames were normalized when read from isogit
const toFilenames = (rows) => rows.map((row) => row[FILE]);
// array members for status results
const FILE = 0;
const HEAD = 1;
const WORKDIR = 2;
class ShadowRepo {
    constructor(options) {
        this.gitDir = getGitDir(options.orgId, options.projectPath);
        this.projectPath = options.projectPath;
        this.packageDirs = options.packageDirs;
    }
    static async getInstance(options) {
        if (!ShadowRepo.instance) {
            ShadowRepo.instance = new ShadowRepo(options);
            await ShadowRepo.instance.init();
        }
        return ShadowRepo.instance;
    }
    async init() {
        this.logger = await core_1.Logger.child('ShadowRepo');
        // initialize the shadow repo if it doesn't exist
        if (!core_1.fs.existsSync(this.gitDir)) {
            this.logger.debug('initializing git repo');
            await this.gitInit();
        }
    }
    /**
     * Initialize a new source tracking shadow repo.  Think of git init
     *
     */
    async gitInit() {
        await core_1.fs.promises.mkdir(this.gitDir, { recursive: true });
        await git.init({ fs: core_1.fs, dir: this.projectPath, gitdir: this.gitDir, defaultBranch: 'main' });
    }
    /**
     * Delete the local tracking files
     *
     * @returns the deleted directory
     */
    async delete() {
        if (typeof core_1.fs.promises.rm === 'function') {
            await core_1.fs.promises.rm(this.gitDir, { recursive: true, force: true });
        }
        else {
            // when node 12 support is over, switch to promise version
            core_1.fs.rmdirSync(this.gitDir, { recursive: true });
        }
        return this.gitDir;
    }
    /**
     * If the status already exists, return it.  Otherwise, set the status before returning.
     * It's kinda like a cache
     *
     * @params noCache: if true, force a redo of the status using FS even if it exists
     *
     * @returns StatusRow[]
     */
    async getStatus(noCache = false) {
        if (!this.status || noCache) {
            try {
                await this.stashIgnoreFile();
                // status hasn't been initalized yet
                this.status = await git.statusMatrix({
                    fs: core_1.fs,
                    dir: this.projectPath,
                    gitdir: this.gitDir,
                    filepaths: this.packageDirs.map((dir) => dir.path),
                    // filter out hidden files and __tests__ patterns, regardless of gitignore
                    filter: (f) => !f.includes(`${path.sep}.`) && !f.includes('__tests__'),
                });
                // isomorphic-git stores things in unix-style tree.  Convert to windows-style if necessary
                if (os.type() === 'Windows_NT') {
                    this.status = this.status.map((row) => [path.normalize(row[FILE]), row[HEAD], row[WORKDIR], row[3]]);
                }
            }
            finally {
                await this.unStashIgnoreFile();
            }
        }
        return this.status;
    }
    /**
     * returns any change (add, modify, delete)
     */
    async getChangedRows() {
        return (await this.getStatus()).filter((file) => file[HEAD] !== file[WORKDIR]);
    }
    /**
     * returns any change (add, modify, delete)
     */
    async getChangedFilenames() {
        return toFilenames(await this.getChangedRows());
    }
    async getDeletes() {
        return (await this.getStatus()).filter((file) => file[WORKDIR] === 0);
    }
    async getDeleteFilenames() {
        return toFilenames(await this.getDeletes());
    }
    /**
     * returns adds and modifies but not deletes
     */
    async getNonDeletes() {
        return (await this.getStatus()).filter((file) => file[WORKDIR] === 2);
    }
    /**
     * returns adds and modifies but not deletes
     */
    async getNonDeleteFilenames() {
        return toFilenames(await this.getNonDeletes());
    }
    async getAdds() {
        return (await this.getStatus()).filter((file) => file[HEAD] === 0 && file[WORKDIR] === 2);
    }
    async getAddFilenames() {
        return toFilenames(await this.getAdds());
    }
    /**
     * returns files that were not added or deleted, but changed locally
     */
    async getModifies() {
        return (await this.getStatus()).filter((file) => file[HEAD] === 1 && file[WORKDIR] === 2);
    }
    async getModifyFilenames() {
        return toFilenames(await this.getModifies());
    }
    /**
     * Look through status and stage all changes, then commit
     *
     * @param fileList list of files to commit (full paths)
     * @param message: commit message (include org username and id)
     *
     * @returns sha (string)
     */
    async commitChanges({ deployedFiles = [], deletedFiles = [], message = 'sfdx source tracking', } = {}) {
        // if no files are specified, commit all changes
        if (deployedFiles.length === 0 && deletedFiles.length === 0) {
            // this is valid, might not be an error
            return 'no files to commit';
        }
        this.logger.debug('changes are', deployedFiles);
        this.logger.debug('deletes are', deletedFiles);
        await this.stashIgnoreFile();
        // these are stored in posix/style/path format.  We have to convert inbound stuff from windows
        if (os.type() === 'Windows_NT') {
            deployedFiles = deployedFiles.map((filepath) => path.normalize(filepath).split(path.sep).join(path.posix.sep));
            deletedFiles = deletedFiles.map((filepath) => path.normalize(filepath).split(path.sep).join(path.posix.sep));
        }
        try {
            // stage changes
            await Promise.all([
                ...deployedFiles.map((filepath) => git.add({ fs: core_1.fs, dir: this.projectPath, gitdir: this.gitDir, filepath })),
                ...deletedFiles.map((filepath) => git.remove({ fs: core_1.fs, dir: this.projectPath, gitdir: this.gitDir, filepath })),
            ]);
            const sha = await git.commit({
                fs: core_1.fs,
                dir: this.projectPath,
                gitdir: this.gitDir,
                message,
                author: { name: 'sfdx source tracking' },
            });
            // status changed as a result of the commit.  This prevents users from having to run getStatus(true) to avoid cache
            await this.getStatus(true);
            return sha;
        }
        finally {
            await this.unStashIgnoreFile();
        }
    }
    async stashIgnoreFile() {
        const originalLocation = path.join(this.projectPath, gitIgnoreFileName);
        // another process may have already stashed the file
        if (core_1.fs.existsSync(originalLocation)) {
            await core_1.fs.promises.rename(originalLocation, path.join(this.projectPath, stashedGitIgnoreFileName));
        }
    }
    async unStashIgnoreFile() {
        const stashedLocation = path.join(this.projectPath, stashedGitIgnoreFileName);
        // another process may have already un-stashed the file
        if (core_1.fs.existsSync(stashedLocation)) {
            await core_1.fs.promises.rename(stashedLocation, path.join(this.projectPath, gitIgnoreFileName));
        }
    }
}
exports.ShadowRepo = ShadowRepo;
//# sourceMappingURL=localShadowRepo.js.map