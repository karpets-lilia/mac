import { Org, SfdxProject } from '@salesforce/core';
import { AsyncCreatable } from '@salesforce/kit';
import { ComponentSet, SourceComponent, FileResponse } from '@salesforce/source-deploy-retrieve';
import { RemoteSyncInput, StatusOutputRow, ChangeOptions, ChangeResult, ChangeOptionType, LocalUpdateOptions } from './shared/types';
export interface SourceTrackingOptions {
    org: Org;
    project: SfdxProject;
    /** @deprecated not used defaults to sfdxProject sourceApiVersion unless provided */
    apiVersion?: string;
}
/**
 * Manages source tracking files (remote and local)
 *
 * const tracking = await SourceTracking.create({org: this.org, project: this.project});
 *
 */
export declare class SourceTracking extends AsyncCreatable {
    private orgId;
    private project;
    private projectPath;
    private packagesDirs;
    private username;
    private logger;
    private localRepo;
    private remoteSourceTrackingService;
    private forceIgnore;
    constructor(options: SourceTrackingOptions);
    init(): Promise<void>;
    localChangesAsComponentSet(): Promise<ComponentSet>;
    /**
     * Does most of the work for the force:source:status command.
     * Outputs need a bit of massage since this aims to provide nice json.
     *
     * @param local you want local status
     * @param remote you want remote status
     * @returns StatusOutputRow[]
     */
    getStatus({ local, remote }: {
        local: boolean;
        remote: boolean;
    }): Promise<StatusOutputRow[]>;
    /**
     * Get metadata changes made locally and in the org.
     *
     * @returns local and remote changed metadata
     *
     */
    getChanges<T extends ChangeOptionType>(options?: ChangeOptions): Promise<T[]>;
    /**
     *
     * returns immediately if there are no changesToDelete
     *
     * @param changesToDelete array of SourceComponent
     */
    deleteFilesAndUpdateTracking(changesToDelete: SourceComponent[]): Promise<FileResponse[]>;
    /**
     * Update tracking for the options passed.
     *
     * @param options the files to update
     */
    updateLocalTracking(options: LocalUpdateOptions): Promise<void>;
    /**
     * Mark remote source tracking files so say that we have received the latest version from the server
     * Optionall skip polling for the SourceMembers to exist on the server and be updated in local files
     */
    updateRemoteTracking(fileResponses: RemoteSyncInput[], skipPolling?: boolean): Promise<void>;
    /**
     * If the local tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists.
     * Useful before parallel operations
     */
    ensureLocalTracking(): Promise<void>;
    /**
     * If the remote tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists.
     * Useful before parallel operations
     */
    ensureRemoteTracking(initializeWithQuery?: boolean): Promise<void>;
    /**
     * Deletes the local tracking shadowRepo
     * return the list of files that were in it
     */
    clearLocalTracking(): Promise<string>;
    /**
     * Commits all the local changes so that no changes are present in status
     */
    resetLocalTracking(): Promise<string[]>;
    /**
     * Deletes the remote tracking files
     */
    clearRemoteTracking(): Promise<string>;
    /**
     * Sets the files to max revision so that no changes appear
     */
    resetRemoteTracking(serverRevision?: number): Promise<number>;
    /**
     * Compares local and remote changes to detect conflicts
     */
    getConflicts(): Promise<ChangeResult[]>;
    /**
     * uses SDR to translate remote metadata records into local file paths (which only typically have the filename).
     *
     * @input elements: ChangeResult[]
     * @input excludeUnresolvables: boolean Filter out components where you can't get the name and type (that is, it's probably not a valid source component)
     * @input resolveDeleted: constructs a virtualTree instead of the actual filesystem--useful when the files no longer exist
     * @input useFsForceIgnore: (default behavior) use forceIgnore from the filesystem.  If false, uses the base forceIgnore from SDR
     */
    private populateTypesAndNames;
    private getLocalStatusRows;
    /**
     * uses SDR to translate remote metadata records into local file paths
     */
    private populateFilePaths;
    private ensureRelative;
    private getLocalChangesAsFilenames;
    private localChangesToOutputRow;
    private remoteChangesToOutputRows;
}
