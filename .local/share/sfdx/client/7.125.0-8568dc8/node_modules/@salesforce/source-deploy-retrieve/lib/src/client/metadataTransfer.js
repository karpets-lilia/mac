"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataTransfer = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const events_1 = require("events");
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const fs = require("graceful-fs");
const convert_1 = require("../convert");
const errors_1 = require("../errors");
const collections_1 = require("../collections");
const types_1 = require("./types");
class MetadataTransfer {
    constructor({ usernameOrConnection, components, apiVersion, id }) {
        this.canceled = false;
        this.event = new events_1.EventEmitter();
        this.usernameOrConnection = usernameOrConnection;
        this.components = components;
        this.apiVersion = apiVersion;
        this.transferId = id;
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
    }
    get id() {
        return this.transferId;
    }
    /**
     * Send the metadata transfer request to the org.
     *
     * @returns AsyncResult from the deploy or retrieve response.
     */
    async start() {
        this.canceled = false;
        const asyncResult = await this.pre();
        this.transferId = asyncResult.id;
        this.logger.debug(`Started metadata transfer. ID = ${this.id}`);
        return asyncResult;
    }
    async pollStatus(frequencyOrOptions, timeout) {
        let pollingOptions = {
            frequency: kit_1.Duration.milliseconds(100),
            timeout: kit_1.Duration.minutes(60),
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            poll: this.poll.bind(this),
        };
        if ((0, ts_types_1.isNumber)(frequencyOrOptions)) {
            pollingOptions.frequency = kit_1.Duration.milliseconds(frequencyOrOptions);
        }
        else if (frequencyOrOptions !== undefined) {
            pollingOptions = { ...pollingOptions, ...frequencyOrOptions };
        }
        if ((0, ts_types_1.isNumber)(timeout)) {
            pollingOptions.timeout = kit_1.Duration.seconds(timeout);
        }
        const pollingClient = await core_1.PollingClient.create(pollingOptions);
        try {
            this.logger.debug(`Polling for metadata transfer status. ID = ${this.id}`);
            this.logger.debug(`Polling frequency (ms): ${pollingOptions.frequency.milliseconds}`);
            this.logger.debug(`Polling timeout (min): ${pollingOptions.timeout.minutes}`);
            const completedMdapiStatus = (await pollingClient.subscribe());
            const result = await this.post(completedMdapiStatus);
            if (completedMdapiStatus.status === types_1.RequestStatus.Canceled) {
                this.event.emit('cancel', completedMdapiStatus);
            }
            else {
                this.event.emit('finish', result);
            }
            return result;
        }
        catch (e) {
            const err = e;
            const error = new errors_1.MetadataTransferError('md_request_fail', err.message);
            if (error.stack && err.stack) {
                // append the original stack to this new error
                error.stack += `\nDUE TO:\n${err.stack}`;
            }
            if (this.event.listenerCount('error') === 0) {
                throw error;
            }
            this.event.emit('error', error);
        }
    }
    onUpdate(subscriber) {
        this.event.on('update', subscriber);
    }
    onFinish(subscriber) {
        this.event.on('finish', subscriber);
    }
    onCancel(subscriber) {
        this.event.on('cancel', subscriber);
    }
    onError(subscriber) {
        this.event.on('error', subscriber);
    }
    async maybeSaveTempDirectory(target, cs) {
        const mdapiTempDir = process.env.SFDX_MDAPI_TEMP_DIR;
        if (mdapiTempDir) {
            process.emitWarning('The SFDX_MDAPI_TEMP_DIR environment variable is set, which may degrade performance');
            this.logger.debug(`Converting metadata to: ${mdapiTempDir} because the SFDX_MDAPI_TEMP_DIR environment variable is set`);
            try {
                const source = cs || this.components || new collections_1.ComponentSet();
                const converter = new convert_1.MetadataConverter();
                await converter.convert(source, target, {
                    type: 'directory',
                    outputDirectory: mdapiTempDir,
                });
                if (target === 'source') {
                    // for source convert the package.xml isn't included so write it separately
                    fs.writeFileSync((0, path_1.join)(mdapiTempDir, 'package.xml'), source.getPackageXml());
                }
            }
            catch (e) {
                this.logger.debug(e);
            }
        }
    }
    async getConnection() {
        if (typeof this.usernameOrConnection === 'string') {
            this.usernameOrConnection = await core_1.Connection.create({
                authInfo: await core_1.AuthInfo.create({ username: this.usernameOrConnection }),
            });
            if (this.apiVersion && this.apiVersion !== this.usernameOrConnection.version) {
                this.usernameOrConnection.setApiVersion(this.apiVersion);
                this.logger.debug(`Overriding apiVersion to: ${this.apiVersion}`);
            }
        }
        return this.usernameOrConnection;
    }
    async poll() {
        let completed = false;
        let mdapiStatus;
        if (this.canceled) {
            // This only happens for a canceled retrieve. Canceled deploys are
            // handled via checkStatus response.
            if (!mdapiStatus) {
                mdapiStatus = { id: this.id, success: false, done: true };
            }
            mdapiStatus.status = types_1.RequestStatus.Canceled;
            completed = true;
            this.canceled = false;
        }
        else {
            mdapiStatus = await this.checkStatus();
            completed = mdapiStatus === null || mdapiStatus === void 0 ? void 0 : mdapiStatus.done;
            if (!completed) {
                this.event.emit('update', mdapiStatus);
            }
        }
        this.logger.debug(`MDAPI status update: ${mdapiStatus.status}`);
        return { completed, payload: mdapiStatus };
    }
}
exports.MetadataTransfer = MetadataTransfer;
//# sourceMappingURL=metadataTransfer.js.map