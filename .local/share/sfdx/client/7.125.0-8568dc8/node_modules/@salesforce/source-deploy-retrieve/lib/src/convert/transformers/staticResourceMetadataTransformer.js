"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticResourceMetadataTransformer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const archiver_1 = require("archiver");
const mime_1 = require("mime");
const unzipper_1 = require("unzipper");
const utils_1 = require("../../utils");
const errors_1 = require("../../errors");
const baseMetadataTransformer_1 = require("./baseMetadataTransformer");
class StaticResourceMetadataTransformer extends baseMetadataTransformer_1.BaseMetadataTransformer {
    async toMetadataFormat(component) {
        const { content, type, xml } = component;
        let contentSource;
        if (await this.componentIsExpandedArchive(component)) {
            // toolbelt was using level 9 for static resources, so we'll do the same.
            // Otherwise, you'll see errors like https://github.com/forcedotcom/cli/issues/1098
            const zip = (0, archiver_1.create)('zip', { zlib: { level: 9 } });
            zip.directory(content, false);
            void zip.finalize();
            contentSource = zip;
        }
        else {
            contentSource = component.tree.stream(content);
        }
        return [
            {
                source: contentSource,
                output: (0, path_1.join)(type.directoryName, `${(0, utils_1.baseName)(content)}.${type.suffix}`),
            },
            {
                source: component.tree.stream(xml),
                output: (0, path_1.join)(type.directoryName, (0, path_1.basename)(xml)),
            },
        ];
    }
    async toSourceFormat(component, mergeWith) {
        const { xml, content } = component;
        const writeInfos = [];
        if (content) {
            const componentContentType = await this.getContentType(component);
            const mergeContentPath = mergeWith === null || mergeWith === void 0 ? void 0 : mergeWith.content;
            const baseContentPath = this.getBaseContentPath(component, mergeWith);
            // only unzip an archive component if there isn't a merge component, or the merge component is itself expanded
            const shouldUnzipArchive = StaticResourceMetadataTransformer.ARCHIVE_MIME_TYPES.has(componentContentType) &&
                (!mergeWith || mergeWith.tree.isDirectory(mergeContentPath));
            if (shouldUnzipArchive) {
                const zipBuffer = await component.tree.readFile(content);
                for await (const info of this.createWriteInfosFromArchive(zipBuffer, baseContentPath)) {
                    writeInfos.push(info);
                }
            }
            else {
                const extension = this.getExtensionFromType(componentContentType);
                writeInfos.push({
                    source: component.tree.stream(content),
                    output: `${baseContentPath}.${extension}`,
                });
            }
            writeInfos.push({
                source: component.tree.stream(xml),
                output: (mergeWith === null || mergeWith === void 0 ? void 0 : mergeWith.xml) || component.getPackageRelativePath((0, path_1.basename)(xml), 'source'),
            });
        }
        return writeInfos;
    }
    getBaseContentPath(component, mergeWith) {
        const baseContentPath = (mergeWith === null || mergeWith === void 0 ? void 0 : mergeWith.content) || component.getPackageRelativePath(component.content, 'source');
        return (0, path_1.join)((0, path_1.dirname)(baseContentPath), (0, utils_1.baseName)(baseContentPath));
    }
    /**
     * "Expanded" refers to a component whose content file is a zip file, and its current
     * state is unzipped.
     */
    async componentIsExpandedArchive(component) {
        const { content, tree } = component;
        if (tree.isDirectory(content)) {
            const contentType = await this.getContentType(component);
            if (StaticResourceMetadataTransformer.ARCHIVE_MIME_TYPES.has(contentType)) {
                return true;
            }
            throw new errors_1.LibraryError('error_static_resource_expected_archive_type', [contentType, component.name]);
        }
        return false;
    }
    async *createWriteInfosFromArchive(zipBuffer, baseDir) {
        const directory = await unzipper_1.Open.buffer(zipBuffer);
        for (const entry of directory.files) {
            if (entry.type === 'File') {
                yield {
                    source: entry.stream(),
                    output: (0, path_1.join)(baseDir, entry.path),
                };
            }
        }
    }
    async getContentType(component) {
        const resource = (await component.parseXml()).StaticResource;
        if (!resource || !Object.prototype.hasOwnProperty.call(resource, 'contentType')) {
            throw new errors_1.LibraryError('error_static_resource_missing_resource_file', [(0, path_1.join)('staticresources', component.name)]);
        }
        return resource.contentType;
    }
    getExtensionFromType(contentType) {
        // return registered ext, fallback, or the default (application/octet-stream -> bin)
        return ((0, mime_1.getExtension)(contentType) ||
            StaticResourceMetadataTransformer.FALLBACK_TYPE_MAP.get(contentType) ||
            (0, mime_1.getExtension)(StaticResourceMetadataTransformer.DEFAULT_CONTENT_TYPE));
    }
}
exports.StaticResourceMetadataTransformer = StaticResourceMetadataTransformer;
StaticResourceMetadataTransformer.ARCHIVE_MIME_TYPES = new Set([
    'application/zip',
    'application/x-zip-compressed',
    'application/jar',
]);
StaticResourceMetadataTransformer.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
StaticResourceMetadataTransformer.FALLBACK_TYPE_MAP = new Map([
    ['text/javascript', 'js'],
    ['application/x-javascript', 'js'],
    ['application/x-zip-compressed', 'zip'],
    ['text/x-haml', 'haml'],
    ['image/x-png', 'png'],
    ['text/xml', 'xml'],
]);
//# sourceMappingURL=staticResourceMetadataTransformer.js.map