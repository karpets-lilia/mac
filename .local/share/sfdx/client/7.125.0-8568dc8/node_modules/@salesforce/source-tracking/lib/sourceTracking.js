"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringGuard = exports.SourceTracking = exports.getKeyFromStrings = exports.getKeyFromObject = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path = require("path");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const remoteSourceTrackingService_1 = require("./shared/remoteSourceTrackingService");
const localShadowRepo_1 = require("./shared/localShadowRepo");
const filenamesToVirtualTree_1 = require("./shared/filenamesToVirtualTree");
const getKeyFromObject = (element) => {
    if (element.type && element.name) {
        return (0, remoteSourceTrackingService_1.getMetadataKey)(element.type, element.name);
    }
    throw new Error(`unable to complete key from ${JSON.stringify(element)}`);
};
exports.getKeyFromObject = getKeyFromObject;
// external users of SDR might need to convert a fileResponse to a key
exports.getKeyFromStrings = remoteSourceTrackingService_1.getMetadataKey;
/**
 * Manages source tracking files (remote and local)
 *
 * const tracking = await SourceTracking.create({org: this.org, project: this.project});
 *
 */
class SourceTracking extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.orgId = options.org.getOrgId();
        this.username = options.org.getUsername();
        this.projectPath = options.project.getPath();
        this.packagesDirs = options.project.getPackageDirectories();
        this.logger = core_1.Logger.childFromRoot('SourceTracking');
    }
    async init() {
        // reserved for future use.  If not, can remove asyncCreatable
    }
    async localChangesAsComponentSet() {
        await this.ensureLocalTracking();
        const componentSet = new source_deploy_retrieve_1.ComponentSet();
        const [nonDeletes, deletes] = await Promise.all([
            this.localRepo.getNonDeleteFilenames(),
            this.localRepo.getDeleteFilenames(),
        ]);
        if (nonDeletes.length === 0 && deletes.length === 0) {
            this.logger.debug('no local changes found in source tracking files');
            return componentSet;
        }
        // optimistic resolution...some files may not be possible to resolve
        const resolverForNonDeletes = new source_deploy_retrieve_1.MetadataResolver();
        // we need virtual components for the deletes.
        // TODO: could we use the same for the non-deletes?
        const resolverForDeletes = new source_deploy_retrieve_1.MetadataResolver(undefined, (0, filenamesToVirtualTree_1.filenamesToVirtualTree)(deletes));
        nonDeletes
            .flatMap((filename) => {
            try {
                return resolverForNonDeletes.getComponentsFromPath(filename);
            }
            catch (e) {
                this.logger.warn(`unable to resolve ${filename}`);
                return undefined;
            }
        })
            .filter(sourceComponentGuard)
            .map((component) => componentSet.add(component));
        deletes
            .flatMap((filename) => resolverForDeletes.getComponentsFromPath(filename))
            .filter(sourceComponentGuard)
            .map((component) => componentSet.add(component, true));
        return componentSet;
    }
    /**
     * Get metadata changes made locally and in the org.
     *
     * @returns local and remote changed metadata
     */
    async getChanges(options) {
        if ((options === null || options === void 0 ? void 0 : options.origin) === 'local') {
            let filenames = [];
            await this.ensureLocalTracking();
            if (options.state === 'modify') {
                filenames = await this.localRepo.getModifyFilenames();
            }
            if (options.state === 'nondelete') {
                filenames = await this.localRepo.getNonDeleteFilenames();
            }
            if (options.state === 'delete') {
                filenames = await this.localRepo.getDeleteFilenames();
            }
            if (options.state === 'add') {
                filenames = await this.localRepo.getAddFilenames();
            }
            if (options.format === 'string') {
                return filenames;
            }
            if (options.format === 'ChangeResult') {
                return filenames.map((filename) => ({
                    filenames: [filename],
                    origin: 'local',
                }));
            }
            if (options.format === 'SourceComponent') {
                const resolver = options.state === 'delete'
                    ? new source_deploy_retrieve_1.MetadataResolver(undefined, (0, filenamesToVirtualTree_1.filenamesToVirtualTree)(filenames))
                    : new source_deploy_retrieve_1.MetadataResolver();
                return filenames
                    .flatMap((filename) => {
                    try {
                        return resolver.getComponentsFromPath(filename);
                    }
                    catch (e) {
                        this.logger.warn(`unable to resolve ${filename}`);
                        return undefined;
                    }
                })
                    .filter(sourceComponentGuard);
            }
        }
        if (options && options.origin === 'remote') {
            await this.ensureRemoteTracking();
            const remoteChanges = await this.remoteSourceTrackingService.retrieveUpdates();
            this.logger.debug('remoteChanges', remoteChanges);
            let filteredChanges = [];
            if (options.state === 'add') {
                filteredChanges = remoteChanges.filter((change) => !change.deleted && !change.modified);
            }
            else if (options.state === 'modify') {
                filteredChanges = remoteChanges.filter((change) => change.modified);
            }
            else if (options.state === 'delete') {
                filteredChanges = remoteChanges.filter((change) => change.deleted);
            }
            else if (options.state === 'nondelete') {
                filteredChanges = remoteChanges.filter((change) => !change.deleted);
            }
            if (options.format === 'ChangeResult') {
                return filteredChanges.map((change) => ({ ...change, origin: 'remote' }));
            }
            // turn it into a componentSet to resolve filenames
            const remoteChangesAsComponentLike = filteredChanges.map((element) => ({
                type: element === null || element === void 0 ? void 0 : element.type,
                fullName: element === null || element === void 0 ? void 0 : element.name,
            }));
            const remoteChangesAsComponentSet = new source_deploy_retrieve_1.ComponentSet(remoteChangesAsComponentLike);
            const matchingLocalSourceComponentsSet = source_deploy_retrieve_1.ComponentSet.fromSource({
                fsPaths: this.packagesDirs.map((dir) => dir.path),
                include: remoteChangesAsComponentSet,
            });
            if (options.format === 'string') {
                return matchingLocalSourceComponentsSet
                    .getSourceComponents()
                    .toArray()
                    .flatMap((component) => [component.xml, ...component.walkContent()].filter((filename) => filename));
            }
            else if (options.format === 'SourceComponent') {
                return matchingLocalSourceComponentsSet.getSourceComponents().toArray();
            }
        }
        // by default return all local and remote changes
        // eslint-disable-next-line no-console
        this.logger.debug(options);
        return [];
    }
    /**
     *
     * returns immediately if there are no changesToDelete
     *
     * @param changesToDelete array of SourceComponent
     */
    async deleteFilesAndUpdateTracking(changesToDelete) {
        if (changesToDelete.length === 0) {
            return [];
        }
        const sourceComponentByFileName = new Map();
        changesToDelete.flatMap((component) => [component.xml, ...component.walkContent()]
            .filter((filename) => filename)
            .map((filename) => sourceComponentByFileName.set(filename, component)));
        const filenames = Array.from(sourceComponentByFileName.keys());
        // delete the files
        await Promise.all(filenames.map((filename) => fs.promises.unlink(filename)));
        // update the tracking files.  We're simulating SDR-style fileResponse
        await Promise.all([
            this.updateLocalTracking({ deletedFiles: filenames }),
            this.updateRemoteTracking(changesToDelete.map((component) => ({
                type: component.type.name,
                fullName: component.fullName,
                state: source_deploy_retrieve_1.ComponentStatus.Deleted,
            })), true // skip polling because it's a pull
            ),
        ]);
        return filenames.map((filename) => {
            var _a, _b;
            return ({
                state: 'Deleted',
                filename,
                type: (_a = sourceComponentByFileName.get(filename)) === null || _a === void 0 ? void 0 : _a.type.name,
                fullName: (_b = sourceComponentByFileName.get(filename)) === null || _b === void 0 ? void 0 : _b.fullName,
            });
        });
    }
    /**
     * Update tracking for the options passed.
     *
     * @param options the files to update
     */
    async updateLocalTracking(options) {
        var _a, _b;
        await this.ensureLocalTracking();
        await this.localRepo.commitChanges({
            deployedFiles: (_a = options.files) === null || _a === void 0 ? void 0 : _a.map((file) => this.ensureRelative(file)),
            deletedFiles: (_b = options.deletedFiles) === null || _b === void 0 ? void 0 : _b.map((file) => this.ensureRelative(file)),
        });
    }
    /**
     * Mark remote source tracking files so say that we have received the latest version from the server
     * Optionall skip polling for the SourceMembers to exist on the server and be updated in local files
     */
    async updateRemoteTracking(fileResponses, skipPolling = false) {
        // false to explicitly NOT query until we do the polling
        await this.ensureRemoteTracking(false);
        if (!skipPolling) {
            // poll to make sure we have the updates before syncing the ones from metadataKeys
            await this.remoteSourceTrackingService.pollForSourceTracking(fileResponses);
        }
        await this.remoteSourceTrackingService.syncSpecifiedElements(fileResponses);
    }
    /**
     * If the local tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists.
     * Useful before parallel operations
     */
    async ensureLocalTracking() {
        if (this.localRepo) {
            return;
        }
        this.localRepo = await localShadowRepo_1.ShadowRepo.create({
            orgId: this.orgId,
            projectPath: this.projectPath,
            packageDirs: this.packagesDirs,
        });
        // loads the status from file so that it's cached
        await this.localRepo.getStatus();
    }
    /**
     * If the remote tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists.
     * Useful before parallel operations
     */
    async ensureRemoteTracking(initializeWithQuery = false) {
        if (this.remoteSourceTrackingService) {
            this.logger.debug('ensureRemoteTracking: remote tracking already exists');
            return;
        }
        this.logger.debug('ensureRemoteTracking: remote tracking does not exist yet; getting instance');
        this.remoteSourceTrackingService = await remoteSourceTrackingService_1.RemoteSourceTrackingService.getInstance({
            username: this.username,
            orgId: this.orgId,
        });
        if (initializeWithQuery) {
            await this.remoteSourceTrackingService.retrieveUpdates();
        }
    }
    /**
     * Deletes the local tracking shadowRepo
     * return the list of files that were in it
     */
    async clearLocalTracking() {
        await this.ensureLocalTracking();
        return this.localRepo.delete();
    }
    /**
     * Commits all the local changes so that no changes are present in status
     */
    async resetLocalTracking() {
        await this.ensureLocalTracking();
        const [deletes, nonDeletes] = await Promise.all([
            this.localRepo.getDeleteFilenames(),
            this.localRepo.getNonDeleteFilenames(),
        ]);
        await this.localRepo.commitChanges({
            deletedFiles: deletes,
            deployedFiles: nonDeletes,
            message: 'via resetLocalTracking',
        });
        return [...deletes, ...nonDeletes];
    }
    /**
     * Deletes the remote tracking files
     */
    async clearRemoteTracking() {
        return remoteSourceTrackingService_1.RemoteSourceTrackingService.delete(this.orgId);
    }
    /**
     * Sets the files to max revision so that no changes appear
     */
    async resetRemoteTracking(serverRevision) {
        await this.ensureRemoteTracking();
        const resetMembers = await this.remoteSourceTrackingService.reset(serverRevision);
        return resetMembers.length;
    }
    /**
     * uses SDR to translate remote metadata records into local file paths (which only typically have the filename).
     *
     * @input elements: ChangeResult[]
     * @input excludeUnresolvables: boolean Filter out components where you can't get the name and type (that is, it's probably not a valid source component)
     */
    populateTypesAndNames({ elements, excludeUnresolvable = false, resolveDeleted = false, }) {
        if (elements.length === 0) {
            return [];
        }
        this.logger.debug(`populateTypesAndNames for ${elements.length} change elements`);
        const filenames = elements.flatMap((element) => element.filenames).filter(exports.stringGuard);
        // component set generated from the filenames on all local changes
        const resolver = new source_deploy_retrieve_1.MetadataResolver(undefined, resolveDeleted ? (0, filenamesToVirtualTree_1.filenamesToVirtualTree)(filenames) : undefined);
        const sourceComponents = filenames
            .flatMap((filename) => {
            try {
                return resolver.getComponentsFromPath(filename);
            }
            catch (e) {
                this.logger.warn(`unable to resolve ${filename}`);
                return undefined;
            }
        })
            .filter(sourceComponentGuard);
        this.logger.debug(` matching SourceComponents have ${sourceComponents.length} items from local`);
        // make it simpler to find things later
        const elementMap = new Map();
        elements.map((element) => {
            var _a;
            (_a = element.filenames) === null || _a === void 0 ? void 0 : _a.map((filename) => {
                elementMap.set(this.ensureRelative(filename), element);
            });
        });
        // iterates the local components and sets their filenames
        sourceComponents.map((matchingComponent) => {
            if ((matchingComponent === null || matchingComponent === void 0 ? void 0 : matchingComponent.fullName) && (matchingComponent === null || matchingComponent === void 0 ? void 0 : matchingComponent.type.name)) {
                const filenamesFromMatchingComponent = [matchingComponent.xml, ...matchingComponent.walkContent()];
                filenamesFromMatchingComponent.map((filename) => {
                    if (filename && elementMap.has(filename)) {
                        // add the type/name from the componentSet onto the element
                        elementMap.set(filename, {
                            ...elementMap.get(filename),
                            type: matchingComponent.type.name,
                            name: matchingComponent.fullName,
                        });
                    }
                });
            }
        });
        return excludeUnresolvable
            ? Array.from(new Set(elementMap.values())).filter((changeResult) => changeResult.name && changeResult.type)
            : Array.from(new Set(elementMap.values()));
    }
    async getConflicts() {
        // we're going to need have both initialized
        await Promise.all([this.ensureRemoteTracking(), this.ensureLocalTracking()]);
        const localChanges = await this.getChanges({
            state: 'nondelete',
            origin: 'local',
            format: 'ChangeResult',
        });
        // remote adds won't have a filename
        const remoteChanges = this.populateFilePaths(await this.getChanges({ origin: 'remote', state: 'nondelete', format: 'ChangeResult' }));
        // index them by filename
        const fileNameIndex = new Map();
        remoteChanges.map((change) => {
            var _a;
            (_a = change.filenames) === null || _a === void 0 ? void 0 : _a.map((filename) => {
                fileNameIndex.set(filename, change);
            });
        });
        const conflicts = new Set();
        localChanges.map((change) => {
            var _a;
            (_a = change.filenames) === null || _a === void 0 ? void 0 : _a.map((filename) => {
                if (fileNameIndex.has(filename)) {
                    conflicts.add({ ...fileNameIndex.get(filename) });
                }
            });
        });
        // deeply de-dupe
        return Array.from(conflicts);
    }
    /**
     * uses SDR to translate remote metadata records into local file paths
     */
    populateFilePaths(elements) {
        if (elements.length === 0) {
            return [];
        }
        this.logger.debug('populateFilePaths for change elements', elements);
        // component set generated from an array of ComponentLike from all the remote changes
        const remoteChangesAsComponentLike = elements.map((element) => ({
            type: element === null || element === void 0 ? void 0 : element.type,
            fullName: element === null || element === void 0 ? void 0 : element.name,
        }));
        const remoteChangesAsComponentSet = new source_deploy_retrieve_1.ComponentSet(remoteChangesAsComponentLike);
        this.logger.debug(` the generated component set has ${remoteChangesAsComponentSet.size.toString()} items`);
        if (remoteChangesAsComponentSet.size < elements.length) {
            throw new Error(`unable to generate complete component set for ${elements
                .map((element) => `${element.name}(${element.type})`)
                .join(',')}`);
        }
        const matchingLocalSourceComponentsSet = source_deploy_retrieve_1.ComponentSet.fromSource({
            fsPaths: this.packagesDirs.map((dir) => dir.path),
            include: remoteChangesAsComponentSet,
        });
        this.logger.debug(` local source-backed component set has ${matchingLocalSourceComponentsSet.size.toString()} items from remote`);
        // make it simpler to find things later
        const elementMap = new Map();
        elements.map((element) => {
            elementMap.set((0, exports.getKeyFromObject)(element), element);
        });
        // iterates the local components and sets their filenames
        for (const matchingComponent of matchingLocalSourceComponentsSet.getSourceComponents().toArray()) {
            if (matchingComponent.fullName && matchingComponent.type.name) {
                this.logger.debug(`${matchingComponent.fullName}|${matchingComponent.type.name} matches ${matchingComponent.xml} and maybe ${matchingComponent.walkContent().toString()}`);
                const key = (0, exports.getKeyFromStrings)(matchingComponent.type.name, matchingComponent.fullName);
                elementMap.set(key, {
                    ...elementMap.get(key),
                    modified: true,
                    filenames: [matchingComponent.xml, ...matchingComponent.walkContent()].filter((filename) => filename),
                });
            }
        }
        return Array.from(elementMap.values());
    }
    ensureRelative(filePath) {
        return path.isAbsolute(filePath) ? path.relative(this.projectPath, filePath) : filePath;
    }
}
exports.SourceTracking = SourceTracking;
const stringGuard = (input) => {
    return typeof input === 'string';
};
exports.stringGuard = stringGuard;
const sourceComponentGuard = (input) => {
    return input instanceof source_deploy_retrieve_1.SourceComponent;
};
//# sourceMappingURL=sourceTracking.js.map