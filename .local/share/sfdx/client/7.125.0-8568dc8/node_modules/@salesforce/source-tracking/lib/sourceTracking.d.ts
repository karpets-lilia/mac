import { Org, SfdxProject } from '@salesforce/core';
import { AsyncCreatable } from '@salesforce/kit';
import { ComponentSet, SourceComponent, FileResponse } from '@salesforce/source-deploy-retrieve';
import { RemoteChangeElement } from './shared/remoteSourceTrackingService';
import { RemoteSyncInput } from './shared/types';
export declare const getKeyFromObject: (element: RemoteChangeElement | ChangeResult) => string;
export declare const getKeyFromStrings: (metadataType: string, metadataName: string) => string;
export declare type ChangeOptionType = ChangeResult | SourceComponent | string;
export interface ChangeOptions {
    origin: 'local' | 'remote';
    state: 'add' | 'delete' | 'modify' | 'nondelete';
    format: 'ChangeResult' | 'SourceComponent' | 'string';
}
export interface LocalUpdateOptions {
    files?: string[];
    deletedFiles?: string[];
}
/**
 * Summary type that supports both local and remote change types
 */
export declare type ChangeResult = Partial<RemoteChangeElement> & {
    origin: 'local' | 'remote';
    filenames?: string[];
};
export interface ConflictError {
    message: string;
    name: 'conflict';
    conflicts: ChangeResult[];
}
export interface SourceTrackingOptions {
    org: Org;
    project: SfdxProject;
    /** defaults to sfdxProject sourceApiVersion unless provided */
    apiVersion?: string;
}
/**
 * Manages source tracking files (remote and local)
 *
 * const tracking = await SourceTracking.create({org: this.org, project: this.project});
 *
 */
export declare class SourceTracking extends AsyncCreatable {
    private orgId;
    private projectPath;
    private packagesDirs;
    private username;
    private logger;
    private localRepo;
    private remoteSourceTrackingService;
    constructor(options: SourceTrackingOptions);
    init(): Promise<void>;
    localChangesAsComponentSet(): Promise<ComponentSet>;
    /**
     * Get metadata changes made locally and in the org.
     *
     * @returns local and remote changed metadata
     */
    getChanges<T extends ChangeOptionType>(options?: ChangeOptions): Promise<T[]>;
    /**
     *
     * returns immediately if there are no changesToDelete
     *
     * @param changesToDelete array of SourceComponent
     */
    deleteFilesAndUpdateTracking(changesToDelete: SourceComponent[]): Promise<FileResponse[]>;
    /**
     * Update tracking for the options passed.
     *
     * @param options the files to update
     */
    updateLocalTracking(options: LocalUpdateOptions): Promise<void>;
    /**
     * Mark remote source tracking files so say that we have received the latest version from the server
     * Optionall skip polling for the SourceMembers to exist on the server and be updated in local files
     */
    updateRemoteTracking(fileResponses: RemoteSyncInput[], skipPolling?: boolean): Promise<void>;
    /**
     * If the local tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists.
     * Useful before parallel operations
     */
    ensureLocalTracking(): Promise<void>;
    /**
     * If the remote tracking shadowRepo doesn't exist, it will be created.
     * Does nothing if it already exists.
     * Useful before parallel operations
     */
    ensureRemoteTracking(initializeWithQuery?: boolean): Promise<void>;
    /**
     * Deletes the local tracking shadowRepo
     * return the list of files that were in it
     */
    clearLocalTracking(): Promise<string>;
    /**
     * Commits all the local changes so that no changes are present in status
     */
    resetLocalTracking(): Promise<string[]>;
    /**
     * Deletes the remote tracking files
     */
    clearRemoteTracking(): Promise<string>;
    /**
     * Sets the files to max revision so that no changes appear
     */
    resetRemoteTracking(serverRevision?: number): Promise<number>;
    /**
     * uses SDR to translate remote metadata records into local file paths (which only typically have the filename).
     *
     * @input elements: ChangeResult[]
     * @input excludeUnresolvables: boolean Filter out components where you can't get the name and type (that is, it's probably not a valid source component)
     */
    populateTypesAndNames({ elements, excludeUnresolvable, resolveDeleted, }: {
        elements: ChangeResult[];
        excludeUnresolvable?: boolean;
        resolveDeleted?: boolean;
    }): ChangeResult[];
    getConflicts(): Promise<ChangeResult[]>;
    /**
     * uses SDR to translate remote metadata records into local file paths
     */
    private populateFilePaths;
    private ensureRelative;
}
export declare const stringGuard: (input: string | undefined) => input is string;
