"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renames = exports.replaceRenamedCommands = exports.throwIfInvalid = exports.getTrackingFileVersion = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path = require("path");
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/source-tracking', 'compatibility');
/**
 * A project can have "old" (toolbelt), "new" (plugin-source) or "none" tracking files
 *
 */
const getTrackingFileVersion = (org, projectPath) => {
    const orgsDir = path.join(projectPath, '.sfdx', 'orgs');
    const newFilesDir = path.join(orgsDir, org.getOrgId());
    // has new tracking files based on orgId
    if (fs.existsSync(newFilesDir) && fs.readdirSync(newFilesDir).length > 0) {
        return 'plugin-source';
    }
    const username = org.getUsername();
    if (typeof username === 'string') {
        if (
        // has both of the old files (org:create puts maxRevision.json in the username dir)
        fs.existsSync(path.join(orgsDir, username, 'sourcePathInfos.json')) &&
            fs.existsSync(path.join(orgsDir, username, 'maxRevision.json'))) {
            return 'toolbelt';
        }
    }
    return 'none';
};
exports.getTrackingFileVersion = getTrackingFileVersion;
/**
 * Convenient wrapper for throwing errors with helpful messages so commands don't have to
 *
 * @param org: an Org, typically from a command's this.org
 * @param project: the project path, typically from this.project.
 * @param toValidate: whether your command lives in 'toolbelt' or 'plugin-source'
 * @param command: the command itself including all flags.  Echoed with modification for the user
 */
const throwIfInvalid = ({ org, projectPath, toValidate, command, }) => {
    const trackingFileVersion = (0, exports.getTrackingFileVersion)(org, projectPath);
    if (trackingFileVersion === 'none' || trackingFileVersion === toValidate) {
        return;
    }
    // We expected it to be the toolbelt version but it is using the new tracking files
    if (toValidate === 'toolbelt') {
        throw new core_1.SfdxError(messages.getMessage('sourceTrackingFileVersionMismatch', ['new']), 'SourceTrackingFileVersionMismatch', [
            messages.getMessage('useOtherVersion', ['new', (0, exports.replaceRenamedCommands)(command)]),
            messages.getMessage('clearSuggestion', ['new', (0, exports.replaceRenamedCommands)('sfdx force:source:tracking:clear')]),
        ]);
    }
    // We expected it to be the plugin-source version but it is using the old tracking files
    if (toValidate === 'plugin-source') {
        throw new core_1.SfdxError(messages.getMessage('sourceTrackingFileVersionMismatch', ['old']), 'SourceTrackingFileVersionMismatch', [
            messages.getMessage('useOtherVersion', ['old', (0, exports.replaceRenamedCommands)(command, true)]),
            messages.getMessage('clearSuggestion', ['old', 'sfdx force:source:tracking:clear']),
        ]);
    }
};
exports.throwIfInvalid = throwIfInvalid;
/**
 *
 * @param input the string that might contain things that would be replaced
 * @param reverse use the mappings backward
 * @returns string
 */
const replaceRenamedCommands = (input, reverse = false) => {
    exports.renames.forEach((value, key) => {
        input = reverse ? input.replace(value, key) : input.replace(key, value);
    });
    return input;
};
exports.replaceRenamedCommands = replaceRenamedCommands;
exports.renames = new Map([
    ['force:source:status', 'force:source:beta:status'],
    ['force:source:push', 'force:source:beta:push'],
    ['force:source:pull', 'force:source:beta:pull'],
    ['force:source:tracking:reset', 'force:source:beta:tracking:reset'],
    ['force:source:tracking:clear', 'force:source:beta:tracking:clear'],
]);
//# sourceMappingURL=compatibility.js.map