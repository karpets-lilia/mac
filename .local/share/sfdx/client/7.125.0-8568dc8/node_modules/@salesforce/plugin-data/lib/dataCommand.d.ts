import { SfdxCommand } from '@salesforce/command';
import { AnyJson, Dictionary } from '@salesforce/ts-types';
import { Org } from '@salesforce/core';
import { BaseConnection, ErrorResult, Record, SObject } from 'jsforce';
export interface Metric {
    requestPath: string;
    perfMetrics: AnyJson;
}
interface Result {
    status: number;
    result: AnyJson;
    perfMetrics?: Metric[];
}
export declare abstract class DataCommand extends SfdxCommand {
    private static metrics;
    static addMetric(metric: Metric): void;
    static getMetrics(): Metric[];
    validateIdXorWhereFlags(): void;
    collectErrorMessages(result: ErrorResult): string;
    throwIfFileDoesntExist(path: string): Promise<void>;
    getJsonResultObject(result?: AnyJson, status?: number): Result;
    /**
     * Necessary where plugin commands are extending a base class that extends SfdxCommand
     *
     * @returns Org
     */
    ensureOrg(): Org;
    getConnection(): BaseConnection;
    query(sobject: SObject<unknown>, where: string): Promise<Record<unknown>>;
    protected stringToDictionary(str: string): Dictionary<string | boolean>;
    protected normalize<T>(results: T | T[]): T;
    protected logNestedObject(obj: never, indentation?: number): void;
    /**
     * Takes a sequence of key=value string pairs and produces an object out of them.
     * If you repeat the key, it replaces the value with the subsequent value.
     *
     * @param [keyValuePairs] - The list of key=value pair strings.
     */
    private transformKeyValueSequence;
    private convertToBooleanIfApplicable;
    /**
     * Splits a sequence of 'key=value key="leftValue rightValue"   key=value'
     * into a list of key=value pairs, paying attention to quoted whitespace.
     *
     * This is NOT a full push down-automaton so do NOT expect full error handling/recovery.
     *
     * @param {string} text - The sequence to split
     */
    private parseKeyValueSequence;
}
export {};
