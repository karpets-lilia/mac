"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataCommand = void 0;
const command_1 = require("@salesforce/command");
const ts_types_1 = require("@salesforce/ts-types");
const core_1 = require("@salesforce/core");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore because jsforce doesn't export http-api
const HttpApi = require("jsforce/lib/http-api");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-data', 'messages');
/* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */
// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
const originalRequestMethod = HttpApi.prototype.request;
HttpApi.prototype.request = function (req, ...args) {
    this.once('response', (response) => {
        const metrics = response.headers.perfmetrics;
        if (metrics) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            DataCommand.addMetric({
                requestPath: response.req.path,
                perfMetrics: JSON.parse(metrics),
            });
        }
    });
    return originalRequestMethod.call(this, req, ...args);
};
/* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call*/
class DataCommand extends command_1.SfdxCommand {
    static addMetric(metric) {
        DataCommand.metrics.push(metric);
    }
    static getMetrics() {
        return DataCommand.metrics;
    }
    validateIdXorWhereFlags() {
        if (!this.flags.where && !this.flags.sobjectid) {
            throw new core_1.SfdxError(messages.getMessage('NeitherSobjectidNorWhereError'), 'NeitherSobjectidNorWhereError', [
                messages.getMessage('NeitherSobjectidNorWhereErrorActions'),
            ]);
        }
    }
    collectErrorMessages(result) {
        let errors = '';
        if (result.errors) {
            errors = '\nErrors:\n';
            result.errors.forEach((err) => {
                errors += '  ' + err + '\n';
            });
        }
        return errors;
    }
    async throwIfFileDoesntExist(path) {
        if (!(await core_1.fs.fileExists(path))) {
            throw new core_1.SfdxError(messages.getMessage('PathDoesNotExist', [path]), 'PathDoesNotExist');
        }
    }
    getJsonResultObject(result = this.result.data, status = process.exitCode || 0) {
        const final = { status, result };
        const perfMetrics = DataCommand.getMetrics();
        if (perfMetrics.length)
            final.perfMetrics = perfMetrics;
        return final;
    }
    /**
     * Necessary where plugin commands are extending a base class that extends SfdxCommand
     *
     * @returns Org
     */
    ensureOrg() {
        if (!this.org) {
            throw new Error('This command requires a username. Specify it with the -u parameter or with the "sfdx config:set defaultusername=<username>" command.');
        }
        return this.org;
    }
    getConnection() {
        const safeOrg = this.ensureOrg();
        const connection = this.flags.usetoolingapi
            ? safeOrg.getConnection().tooling
            : safeOrg.getConnection();
        if (this.flags.perflog) {
            if (!connection.callOptions) {
                connection.callOptions = {};
            }
            connection.callOptions.perfOption = 'MINIMUM';
        }
        return connection;
    }
    async query(sobject, where) {
        const queryObject = this.stringToDictionary(where);
        const records = await sobject.find(queryObject, 'id');
        if (!records || records.length === 0) {
            throw new core_1.SfdxError('DataRecordGetNoRecord', messages.getMessage('DataRecordGetNoRecord'));
        }
        if (records.length > 1) {
            throw new core_1.SfdxError('DataRecordGetMultipleRecords', messages.getMessage('DataRecordGetMultipleRecords', [where, this.flags.sobjecttype, records.length]));
        }
        return this.normalize(records);
    }
    stringToDictionary(str) {
        const keyValuePairs = this.parseKeyValueSequence(str);
        return this.transformKeyValueSequence(keyValuePairs);
    }
    normalize(results) {
        // jsforce returns RecordResult | RecordResult[]
        // but we're only ever dealing with a single sobject we are guaranteed to
        // get back a single RecordResult. Nevertheless, we ensure that it's a
        // single RecordResult to make Typescript happy
        return Array.isArray(results) ? results[0] : results;
    }
    logNestedObject(obj, indentation = 0) {
        const space = ' '.repeat(indentation);
        Object.keys(obj).forEach((key) => {
            const value = (0, ts_types_1.get)(obj, key, null);
            if (!!value && typeof value === 'object') {
                this.ux.log(`${space}${key}:`);
                this.logNestedObject(value, indentation + 2);
            }
            else {
                this.ux.log(`${space}${key}: ${value}`);
            }
        });
    }
    /**
     * Takes a sequence of key=value string pairs and produces an object out of them.
     * If you repeat the key, it replaces the value with the subsequent value.
     *
     * @param [keyValuePairs] - The list of key=value pair strings.
     */
    transformKeyValueSequence(keyValuePairs) {
        const constructedObject = {};
        keyValuePairs.forEach((pair) => {
            // Look for the *first* '=' and splits there, ignores any subsequent '=' for this pair
            const eqPosition = pair.indexOf('=');
            if (eqPosition === -1) {
                throw new Error(messages.getMessage('TextUtilMalformedKeyValuePair', [pair]));
            }
            else {
                const key = pair.substr(0, eqPosition);
                constructedObject[key] = this.convertToBooleanIfApplicable(pair.substr(eqPosition + 1));
            }
        });
        return constructedObject;
    }
    convertToBooleanIfApplicable(input) {
        if (input.trim().toLowerCase() === 'false')
            return false;
        if (input.trim().toLowerCase() === 'true')
            return true;
        return input;
    }
    /**
     * Splits a sequence of 'key=value key="leftValue rightValue"   key=value'
     * into a list of key=value pairs, paying attention to quoted whitespace.
     *
     * This is NOT a full push down-automaton so do NOT expect full error handling/recovery.
     *
     * @param {string} text - The sequence to split
     */
    parseKeyValueSequence(text) {
        const separator = /\s/;
        let inSingleQuote = false;
        let inDoubleQuote = false;
        let currentToken = [];
        const keyValuePairs = [];
        const trimmedText = text.trim();
        for (const currentChar of trimmedText) {
            const isSeparator = separator.exec(currentChar);
            if (currentChar === "'" && !inDoubleQuote) {
                inSingleQuote = !inSingleQuote;
                continue;
            }
            else if (currentChar === '"' && !inSingleQuote) {
                inDoubleQuote = !inDoubleQuote;
                continue;
            }
            if (!inSingleQuote && !inDoubleQuote && isSeparator) {
                if (currentToken.length > 0) {
                    keyValuePairs.push(currentToken.join(''));
                    currentToken = [];
                }
            }
            else {
                currentToken.push(currentChar);
            }
        }
        // For the case of only one key=value pair with no separator
        if (currentToken.length > 0) {
            keyValuePairs.push(currentToken.join(''));
        }
        return keyValuePairs;
    }
}
exports.DataCommand = DataCommand;
DataCommand.metrics = [];
//# sourceMappingURL=dataCommand.js.map