"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportApi = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
const path = require("path");
const util = require("util");
const ts_types_1 = require("@salesforce/ts-types");
const core_1 = require("@salesforce/core");
const executors_1 = require("./executors");
const importPlanSchemaFile = path.join(__dirname, '..', '..', '..', '..', 'schema', 'dataImportPlanSchema.json');
const sobjectTreeApiPartPattern = '%s/services/data/v%s/composite/tree/%s';
const jsonContentType = 'application/json';
const xmlContentType = 'application/xml';
const jsonRefRegex = /[.]*["|'][A-Z0-9_]*["|'][ ]*:[ ]*["|']@([A-Z0-9_]*)["|'][.]*/gim;
const xmlRefRegex = /[.]*<[A-Z0-9_]*>@([A-Z0-9_]*)<\/[A-Z0-9_]*[ID]>[.]*/gim;
const INVALID_DATA_IMPORT_ERR_NAME = 'InvalidDataImport';
/**
 * Imports data into an org that was exported to files using the export API.
 */
class ImportApi {
    constructor(org) {
        this.org = org;
        this.responseRefs = [];
        this.sobjectTypes = {};
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
        this.sobjectUrlMap = new Map();
        this.schemaValidator = new core_1.SchemaValidator(this.logger, importPlanSchemaFile);
    }
    /**
     * Inserts given SObject Tree content into given target Org.
     *
     * @param config
     */
    async import(config) {
        const importResults = {};
        this.config = await this.validate(config);
        const refMap = new Map();
        const { contentType, plan, sobjectTreeFiles } = this.config;
        const instanceUrl = this.org.getField(core_1.Org.Fields.INSTANCE_URL);
        const fileFns = [];
        const planFns = [];
        let importPlanRootPath;
        if (sobjectTreeFiles === null || sobjectTreeFiles === void 0 ? void 0 : sobjectTreeFiles.length) {
            sobjectTreeFiles.forEach((file) => {
                const filepath = path.resolve(process.cwd(), file);
                const importConfig = { instanceUrl, refMap, filepath, contentType };
                // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                fileFns.push(() => this.importSObjectTreeFile(importConfig));
            });
        }
        if (plan && this.importPlanConfig) {
            // REVIEWME: support both files and plan in same invocation?
            importPlanRootPath = path.dirname(plan);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            this.importPlanConfig.forEach((sobjectConfig) => {
                const globalSaveRefs = (sobjectConfig.saveRefs != null ? sobjectConfig.saveRefs : false);
                const globalResolveRefs = (sobjectConfig.resolveRefs != null ? sobjectConfig.resolveRefs : false);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                sobjectConfig.files.forEach((fileDef) => {
                    let filepath;
                    let saveRefs = globalSaveRefs;
                    let resolveRefs = globalResolveRefs;
                    // file definition can be just a filepath or an object that
                    // has a filepath and overriding global config
                    if ((0, ts_types_1.isString)(fileDef)) {
                        filepath = fileDef;
                    }
                    else if ((0, ts_types_1.isObject)(fileDef)) {
                        const def = fileDef;
                        filepath = def.file;
                        // override save references, if set
                        saveRefs = (def.saveRefs == null ? globalSaveRefs : def.saveRefs);
                        // override resolve references, if set
                        resolveRefs = (def.resolveRefs == null ? globalResolveRefs : def.resolveRefs);
                    }
                    else {
                        throw new core_1.SfdxError('file definition format unknown.', 'InvalidDataImportPlan');
                    }
                    filepath = path.resolve(importPlanRootPath, filepath);
                    const importConfig = {
                        instanceUrl,
                        saveRefs,
                        resolveRefs,
                        refMap,
                        filepath,
                        contentType,
                    };
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                    planFns.push(() => this.importSObjectTreeFile(importConfig));
                });
            });
        }
        try {
            await (0, executors_1.sequentialExecute)(fileFns);
            await (0, executors_1.sequentialExecute)(planFns);
            importResults.responseRefs = this.responseRefs;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            importResults.sobjectTypes = this.sobjectTypes;
        }
        catch (err) {
            const error = err;
            if ((0, ts_types_1.getString)(error, 'errorCode') === 'ERROR_HTTP_400' && error.message != null) {
                let msg;
                try {
                    msg = JSON.parse(error.message);
                    if (msg.hasErrors && msg.results && msg.results.length > 0) {
                        importResults.errors = msg.results;
                    }
                }
                catch (e2) {
                    // throw original
                }
            }
            throw core_1.SfdxError.wrap(error);
        }
        return importResults;
    }
    getSchema() {
        return this.schemaValidator.loadSync();
    }
    /**
     * Validates the import configuration.  If a plan is passed, validates
     * the plan per the schema.
     *
     * @param config - The data import configuration.
     * @returns Promise.<ImportConfig>
     */
    async validate(config) {
        const { sobjectTreeFiles, plan } = config;
        // --sobjecttreefiles option is required when --plan option is unset
        if (!sobjectTreeFiles && !plan) {
            const err = core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'dataFileNotProvided');
            err.name = INVALID_DATA_IMPORT_ERR_NAME;
            throw err;
        }
        // Prevent both --sobjecttreefiles and --plan option from being set
        if (sobjectTreeFiles && plan) {
            const err = core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'tooManyFiles');
            err.name = INVALID_DATA_IMPORT_ERR_NAME;
            throw err;
        }
        if (plan) {
            const planPath = path.resolve(process.cwd(), plan);
            try {
                core_1.fs.statSync(planPath);
            }
            catch (e) {
                const err = core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'dataFileNotFound', [planPath]);
                err.name = INVALID_DATA_IMPORT_ERR_NAME;
                throw err;
            }
            this.importPlanConfig = JSON.parse(core_1.fs.readFileSync(planPath, 'utf8'));
            try {
                await this.schemaValidator.validate(this.importPlanConfig);
            }
            catch (err) {
                const error = err;
                if (error.name === 'ValidationSchemaFieldErrors') {
                    const e = core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'dataPlanValidationError', [
                        planPath,
                        error.message,
                    ]);
                    e.name = INVALID_DATA_IMPORT_ERR_NAME;
                    throw e;
                }
                throw core_1.SfdxError.wrap(error);
            }
        }
        return config;
    }
    /**
     * Create a hash of sobject { ReferenceId: Type } assigned to this.sobjectTypes.
     * Used to display the sobject type in the results.
     *
     * @param content  The content string defined by the file(s).
     * @param isJson
     */
    createSObjectTypeMap(content, isJson) {
        let contentJson;
        const getTypes = (records = []) => {
            records.forEach((record) => {
                Object.entries(record).forEach(([key, val]) => {
                    if ((0, ts_types_1.isObject)(val)) {
                        const v = val;
                        if (key === 'attributes') {
                            const { referenceId, type } = v;
                            this.sobjectTypes[referenceId] = type;
                        }
                        else {
                            if ((0, ts_types_1.isArray)(v.records)) {
                                getTypes(v.records);
                            }
                        }
                    }
                });
            });
        };
        if (isJson) {
            contentJson = JSON.parse(content);
            if ((0, ts_types_1.isArray)(contentJson.records)) {
                getTypes(contentJson.records);
            }
        }
    }
    // Does some basic validation on the filepath and returns some file metadata such as
    // isJson, refRegex, and headers.
    getSObjectTreeFileMeta(filepath, contentType) {
        const meta = {
            isJson: false,
            headers: {},
            refRegex: new RegExp(/./),
        };
        let tmpContentType;
        // explicitly validate filepath so, if not found, we can return friendly error message
        try {
            core_1.fs.statSync(filepath);
        }
        catch (e) {
            const err = core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'dataFileNotFound', [filepath]);
            err.name = INVALID_DATA_IMPORT_ERR_NAME;
            throw err;
        }
        // determine content type
        if (filepath.endsWith('.json')) {
            tmpContentType = jsonContentType;
            meta.isJson = true;
            meta.refRegex = jsonRefRegex;
        }
        else if (filepath.endsWith('.xml')) {
            tmpContentType = xmlContentType;
            meta.refRegex = xmlRefRegex;
        }
        // unable to determine content type from extension, was a global content type provided?
        if (!tmpContentType) {
            if (!contentType) {
                const err = core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'unknownContentType', [filepath]);
                err.name = INVALID_DATA_IMPORT_ERR_NAME;
                throw err;
            }
            else if (contentType.toUpperCase() === 'JSON') {
                tmpContentType = jsonContentType;
                meta.isJson = true;
                meta.refRegex = jsonRefRegex;
            }
            else if (contentType.toUpperCase() === 'XML') {
                tmpContentType = xmlContentType;
                meta.refRegex = xmlRefRegex;
            }
            else {
                const err = core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'dataFileUnsupported', [contentType]);
                err.name = INVALID_DATA_IMPORT_ERR_NAME;
                throw err;
            }
        }
        meta.headers['content-type'] = tmpContentType;
        return meta;
    }
    // Parse the SObject tree file, resolving any saved refs if specified.
    // Return a promise with the contents of the SObject tree file and the type.
    async parseSObjectTreeFile(filepath, isJson, refRegex, resolveRefs, refMap) {
        let contentStr;
        let contentJson;
        let match;
        let sobject = '';
        const foundRefs = new Set();
        // call identity() so the access token can be auto-updated
        const content = await core_1.fs.readFile(filepath);
        if (!content) {
            throw core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'dataFileEmpty', [filepath]);
        }
        contentStr = content.toString();
        if (isJson) {
            // is valid json?  (save round-trip to server)
            try {
                contentJson = JSON.parse(contentStr);
                // All top level records should be of the same sObject type so just grab the first one
                const type = (0, ts_types_1.getString)(contentJson, 'records[0].attributes.type');
                if (type) {
                    sobject = type.toLowerCase();
                }
            }
            catch (e) {
                throw core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'dataFileInvalidJson', [filepath]);
            }
        }
        // if we're replacing references (@AcmeIncAccountId), find references in content and
        // replace with reference found in previously saved records
        if (resolveRefs && refMap) {
            // find and stash all '@' references
            while ((match = refRegex.exec(contentStr))) {
                foundRefs.add(match[1]);
            }
            if (foundRefs.size > 0 && refMap.size === 0) {
                throw core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'dataFileNoRefId', [filepath]);
            }
            this.logger.debug(`Found references: ${Array.from(foundRefs).toString()}`);
            // loop thru found references and replace with id value
            foundRefs.forEach((ref) => {
                const value = refMap.get(ref.toLowerCase());
                if (value == null) {
                    // REVIEWME: fail?
                    this.logger.warn(`Reference '${ref}' not found in saved record references (${filepath})`);
                }
                else {
                    contentStr = contentStr.replace(new RegExp(`(["'>])@${ref}(["'<])`, 'igm'), `$1${value}$2`);
                }
            });
        }
        // Create map of SObject { referenceId: type } to display the type in output
        this.createSObjectTypeMap(contentStr, isJson);
        return { contentStr, sobject };
    }
    // generate REST API url: http://<sfdc-instance>/v<version>/composite/tree/<sobject>
    // and send the request.
    async sendSObjectTreeRequest(contentStr, sobject, instanceUrl, headers) {
        const apiVersion = this.org.getConnection().getApiVersion();
        let sobjectTreeApiUrl = this.sobjectUrlMap.get(sobject);
        if (!sobjectTreeApiUrl) {
            sobjectTreeApiUrl = util.format(sobjectTreeApiPartPattern, instanceUrl, apiVersion, sobject);
            this.sobjectUrlMap.set(sobject, sobjectTreeApiUrl);
        }
        this.logger.debug(`SObject Tree API URL: ${sobjectTreeApiUrl}`);
        // post request with to-be-insert sobject tree content
        return this.org.getConnection().request({
            method: 'POST',
            url: sobjectTreeApiUrl,
            body: contentStr,
            headers,
        });
    }
    // Parse the response from the SObjectTree request and save refs if specified.
    parseSObjectTreeResponse(response, filepath, isJson, saveRefs, refMap) {
        if (isJson) {
            this.logger.debug(`SObject Tree API results:  ${JSON.stringify(response, null, 4)}`);
            if (response.hasErrors) {
                throw core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'dataImportFailed', [
                    filepath,
                    JSON.stringify(response.results, null, 4),
                ]);
            }
            if ((0, ts_types_1.getNumber)(response, 'results.length')) {
                // REVIEWME: include filepath from which record was define?
                // store results to be output to stdout in aggregated tabular format
                this.responseRefs = this.responseRefs.concat(response.results);
                // if enabled, save references to map to be used to replace references
                // prior to subsequent saves
                if (saveRefs) {
                    for (let i = 0, len = response.results.length, ref; i < len; i++) {
                        ref = response.results[i];
                        if (refMap) {
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                            refMap.set(ref.referenceId.toLowerCase(), ref.id);
                        }
                    }
                }
            }
        }
        else {
            throw new core_1.SfdxError('SObject Tree API XML response parsing not implemented', 'FailedDataImport');
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return response;
    }
    // Imports the SObjectTree from the provided files/plan by making a POST request to the server.
    async importSObjectTreeFile(components) {
        // Get some file metadata
        const { isJson, refRegex, headers } = this.getSObjectTreeFileMeta(components.filepath, components.contentType);
        this.logger.debug(`Importing SObject Tree data from file ${components.filepath}`);
        return this.parseSObjectTreeFile(components.filepath, isJson, refRegex, components.resolveRefs, components.refMap)
            .then(({ contentStr, sobject }) => this.sendSObjectTreeRequest(contentStr, sobject, components.instanceUrl, headers))
            .then((response) => 
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        this.parseSObjectTreeResponse(response, components.filepath, isJson, components.saveRefs, components.refMap))
            .catch((error) => {
            // break the error message string into the variables we want
            if (error.errorCode === 'INVALID_FIELD') {
                const field = error.message.split("'")[1];
                const object = error.message.substr(error.message.lastIndexOf(' ') + 1, error.message.length);
                throw core_1.SfdxError.create('@salesforce/plugin-data', 'importApi', 'FlsError', [field, object]);
            }
            throw core_1.SfdxError.wrap(error);
        });
    }
}
exports.ImportApi = ImportApi;
//# sourceMappingURL=importApi.js.map