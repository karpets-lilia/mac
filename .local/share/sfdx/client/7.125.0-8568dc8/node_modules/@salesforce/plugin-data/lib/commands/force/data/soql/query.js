"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSoqlQueryCommand = exports.SoqlQuery = void 0;
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const reporters_1 = require("../../../../reporters");
const dataSoqlQueryTypes_1 = require("../../../../dataSoqlQueryTypes");
const dataCommand_1 = require("../../../../dataCommand");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-data', 'soql.query');
const commonMessages = core_1.Messages.loadMessages('@salesforce/plugin-data', 'messages');
/**
 * Class to handle a soql query
 *
 * Will collect all records and the column metadata of the query
 */
class SoqlQuery {
    async runSoqlQuery(connection, query, logger) {
        let columns = [];
        logger.debug('running query');
        const result = await connection.autoFetchQuery(query, { autoFetch: true, maxFetch: 50000 });
        logger.debug(`Query complete with ${result.totalSize} records returned`);
        if (result.totalSize) {
            logger.debug('fetching columns for query');
            columns = await this.retrieveColumns(connection, query);
        }
        // remove nextRecordsUrl and force done to true
        delete result.nextRecordsUrl;
        result.done = true;
        return {
            query,
            columns,
            result,
        };
    }
    /**
     * Utility to fetch the columns involved in a soql query.
     *
     * Columns are then transformed into one of three types, Field, SubqueryField and FunctionField. List of
     * fields is returned as the product.
     *
     * @param connection
     * @param query
     */
    async retrieveColumns(connection, query) {
        // eslint-disable-next-line no-underscore-dangle
        const columnUrl = `${connection._baseUrl()}/query?q=${encodeURIComponent(query)}&columns=true`;
        const results = (0, ts_types_1.toJsonMap)(await connection.request(columnUrl));
        const columns = [];
        for (let column of (0, ts_types_1.ensureJsonArray)(results.columnMetadata)) {
            column = (0, ts_types_1.ensureJsonMap)(column);
            const name = (0, ts_types_1.ensureString)(column.columnName);
            if ((0, ts_types_1.isJsonArray)(column.joinColumns) && column.joinColumns.length > 0) {
                if (column.aggregate) {
                    const field = {
                        fieldType: dataSoqlQueryTypes_1.FieldType.subqueryField,
                        name,
                        fields: [],
                    };
                    for (const subcolumn of column.joinColumns) {
                        const f = {
                            fieldType: dataSoqlQueryTypes_1.FieldType.field,
                            name: (0, ts_types_1.ensureString)((0, ts_types_1.ensureJsonMap)(subcolumn).columnName),
                        };
                        if (field.fields)
                            field.fields.push(f);
                    }
                    columns.push(field);
                }
                else {
                    for (const subcolumn of column.joinColumns) {
                        const allSubFieldNames = this.searchSubColumns(subcolumn);
                        const f = {
                            fieldType: dataSoqlQueryTypes_1.FieldType.field,
                            name: `${name}.${allSubFieldNames}`,
                        };
                        columns.push(f);
                    }
                }
            }
            else if (column.aggregate) {
                const field = {
                    fieldType: dataSoqlQueryTypes_1.FieldType.functionField,
                    name: (0, ts_types_1.ensureString)(column.displayName),
                };
                // If it isn't an alias, skip so the display name is used when messaging rows
                if (!/expr[0-9]+/.test(name)) {
                    field.alias = name;
                }
                columns.push(field);
            }
            else {
                columns.push({ fieldType: dataSoqlQueryTypes_1.FieldType.field, name });
            }
        }
        return columns;
    }
    searchSubColumns(parent) {
        const column = (0, ts_types_1.ensureJsonMap)(parent);
        const name = (0, ts_types_1.ensureString)(column.columnName);
        const names = [name];
        const child = (0, ts_types_1.getArray)(parent, 'joinColumns');
        if (child.length) {
            // recursively search for related column names
            child.map((c) => names.push(this.searchSubColumns(c)));
        }
        return names.join('.');
    }
}
exports.SoqlQuery = SoqlQuery;
class DataSoqlQueryCommand extends dataCommand_1.DataCommand {
    /**
     * Command run implementation
     *
     * Returns either a DataSoqlQueryResult or a SfdxResult.
     * When the user is using global '--json' flag an instance of SfdxResult is returned.
     * This is necessary since '--json' flag reports results in the form of SfdxResult
     * and bypasses the definition of start result. The goal is to have the output
     * from '--json' and '--resulformat json' be the same.
     *
     * The DataSoqlQueryResult is necessary to communicate user selections to the reporters.
     * The 'this' object available during display() function does not include user input to
     * the command, which are necessary for reporter selection.
     *
     */
    async run() {
        try {
            if (this.flags.resultformat !== 'json')
                this.ux.startSpinner(messages.getMessage('queryRunningMessage'));
            const query = new SoqlQuery();
            const conn = this.getConnection();
            const queryResult = await query.runSoqlQuery(conn, this.flags.query, this.logger);
            const results = {
                ...queryResult,
            };
            this.displayResults(results);
            return queryResult.result;
        }
        finally {
            if (this.flags.resultformat !== 'json')
                this.ux.stopSpinner();
        }
    }
    displayResults(queryResult) {
        // bypass if --json flag present
        if (!this.flags.json) {
            let reporter;
            switch (this.flags.resultformat) {
                case 'human':
                    reporter = new reporters_1.HumanReporter(queryResult, queryResult.columns, this.ux, this.logger);
                    break;
                case 'json':
                    reporter = new reporters_1.JsonReporter(queryResult, queryResult.columns, this.ux, this.logger);
                    break;
                case 'csv':
                    reporter = new reporters_1.CsvReporter(queryResult, queryResult.columns, this.ux, this.logger);
                    break;
                default:
                    throw new Error(`result format is invalid: ${this.flags.resultformat}`);
            }
            // delegate to selected reporter
            reporter.display();
        }
    }
}
exports.DataSoqlQueryCommand = DataSoqlQueryCommand;
DataSoqlQueryCommand.description = messages.getMessage('description');
DataSoqlQueryCommand.requiresUsername = true;
DataSoqlQueryCommand.examples = messages.getMessage('examples').split(os.EOL);
DataSoqlQueryCommand.flagsConfig = {
    query: command_1.flags.string({
        char: 'q',
        required: true,
        description: messages.getMessage('queryToExecute'),
    }),
    usetoolingapi: command_1.flags.boolean({
        char: 't',
        description: messages.getMessage('queryToolingDescription'),
    }),
    resultformat: command_1.flags.enum({
        char: 'r',
        description: messages.getMessage('resultFormatDescription'),
        options: ['human', 'csv', 'json'],
        default: 'human',
    }),
    perflog: command_1.flags.boolean({
        description: commonMessages.getMessage('perfLogLevelOption'),
        dependsOn: ['json'],
    }),
};
//# sourceMappingURL=query.js.map