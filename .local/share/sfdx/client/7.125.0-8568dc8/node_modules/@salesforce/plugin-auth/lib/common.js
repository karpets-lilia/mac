"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Common = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'messages');
class Common {
    static async handleSideEffects(authInfo, flags) {
        if (flags.setalias)
            await authInfo.setAlias(flags.setalias);
        if (flags.setdefaultdevhubusername || flags.setdefaultusername) {
            await authInfo.setAsDefault({
                defaultUsername: flags.setdefaultusername,
                defaultDevhubUsername: flags.setdefaultdevhubusername,
            });
        }
    }
    static async resolveLoginUrl(instanceUrl) {
        var _a;
        const logger = await core_1.Logger.child('Common', { tag: 'resolveLoginUrl' });
        if (instanceUrl) {
            if (instanceUrl.includes('lightning.force.com')) {
                logger.warn(messages.getMessage('invalidInstanceUrl'));
                throw new core_1.SfdxError(messages.getMessage('invalidInstanceUrl'), 'URL_WARNING');
            }
            return instanceUrl;
        }
        let loginUrl;
        try {
            const project = await core_1.SfdxProject.resolve();
            const projectJson = await project.resolveProjectConfig();
            loginUrl = (0, ts_types_1.getString)(projectJson, 'sfdcLoginUrl', core_1.SfdcUrl.PRODUCTION);
        }
        catch (err) {
            const message = ((0, ts_types_1.isObject)(err) ? (_a = Reflect.get(err, 'message')) !== null && _a !== void 0 ? _a : err : err);
            logger.debug(`error occurred while trying to determine loginUrl: ${message}`);
            loginUrl = core_1.SfdcUrl.PRODUCTION;
        }
        if (loginUrl.includes('lightning.force.com')) {
            logger.warn(messages.getMessage('invalidInstanceUrl'));
            throw new core_1.SfdxError(messages.getMessage('invalidInstanceUrl'), 'URL_WARNING');
        }
        logger.debug(`loginUrl: ${loginUrl}`);
        return loginUrl;
    }
    // fields property is passed in because the consumers of this method have performed the decrypt.
    // This is so we don't have to call authInfo.getFields(true) and decrypt again OR accidentally save an
    // authInfo before it is necessary.
    static async identifyPossibleScratchOrgs(fields, orgAuthInfo) {
        const logger = await core_1.Logger.child('Common', { tag: 'identifyPossibleScratchOrgs' });
        // return if we already know the hub or we know it is a devhub or prod-like
        if (fields.isDevHub || fields.devHubUsername)
            return;
        // there are no hubs to ask, so quit early
        if (!(await core_1.AuthInfo.hasAuthentications()))
            return;
        logger.debug('getting devHubs from authfiles');
        // TODO: return if url is not sandbox-like to avoid constantly asking about production orgs
        // TODO: someday we make this easier by asking the org if it is a scratch org
        const hubAuthInfos = await this.getDevHubAuthInfos();
        logger.debug(`found ${hubAuthInfos.length} DevHubs`);
        if (hubAuthInfos.length === 0)
            return;
        // ask all those orgs if they know this orgId
        await Promise.all(hubAuthInfos.map(async (hubAuthInfo) => {
            try {
                const devHubOrg = await core_1.Org.create({ aliasOrUsername: hubAuthInfo.getUsername() });
                const conn = devHubOrg.getConnection();
                const data = await conn.query(`select Id from ScratchOrgInfo where ScratchOrg = '${core_1.sfdc.trimTo15(fields.orgId)}'`);
                if (data.totalSize > 0) {
                    // if any return a result
                    logger.debug(`found orgId ${fields.orgId} in devhub ${hubAuthInfo.getUsername()}`);
                    try {
                        await orgAuthInfo.save({ ...fields, devHubUsername: hubAuthInfo.getUsername() });
                        logger.debug(`set ${hubAuthInfo.getUsername()} as devhub for scratch org ${orgAuthInfo.getUsername()}`);
                    }
                    catch (error) {
                        logger.debug(`error updating auth file for ${orgAuthInfo.getUsername()}`, error);
                    }
                }
            }
            catch (error) {
                logger.error(`Error connecting to devhub ${hubAuthInfo.getUsername()}`, error);
            }
        }));
    }
    static async getDevHubAuthInfos() {
        return (await Promise.all((await core_1.AuthInfo.listAllAuthFiles())
            .map((fileName) => (0, path_1.basename)(fileName, '.json'))
            .map((username) => core_1.AuthInfo.create({ username })))).filter((possibleHub) => { var _a; return (_a = possibleHub === null || possibleHub === void 0 ? void 0 : possibleHub.getFields()) === null || _a === void 0 ? void 0 : _a.isDevHub; });
    }
}
exports.Common = Common;
//# sourceMappingURL=common.js.map