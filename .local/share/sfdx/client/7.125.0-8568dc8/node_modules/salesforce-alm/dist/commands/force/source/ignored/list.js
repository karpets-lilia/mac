"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceIgnoredCommand = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = require("path");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'source_ignored');
class SourceIgnoredCommand extends command_1.SfdxCommand {
    constructor() {
        super(...arguments);
        this.ignoredFiles = [];
    }
    /**
     * Outputs all forceignored files from package directories of a project,
     * or based on a sourcepath param that points to a specific file or directory.
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async run() {
        try {
            this.forceIgnore = source_deploy_retrieve_1.ForceIgnore.findAndCreate(this.project.getPath());
            let sourcepaths;
            if (this.flags.sourcepath) {
                sourcepaths = [this.flags.sourcepath];
            }
            else {
                sourcepaths = this.project.getUniquePackageDirectories().map((pDir) => pDir.path);
            }
            sourcepaths.forEach((sp) => this.statIgnored(sp.trim()));
            // Command output
            if (this.ignoredFiles.length) {
                this.ux.log('Found the following ignored files:');
                this.ignoredFiles.forEach((filepath) => this.ux.log(filepath));
            }
            else {
                this.ux.log('No ignored files found in paths:');
                sourcepaths.forEach((sp) => this.ux.log(sp));
            }
            return { ignoredFiles: this.ignoredFiles };
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                throw core_1.SfdxError.create('salesforce-alm', 'source_ignored', 'invalidSourcePath', [this.flags.sourcepath]);
            }
            throw core_1.SfdxError.wrap(err);
        }
    }
    // Stat the filepath.  Test if a file, recurse if a directory.
    statIgnored(filepath) {
        const stats = core_1.fs.statSync(filepath);
        if (stats.isDirectory()) {
            this.findIgnored(filepath);
        }
        else {
            this.testIgnored(filepath);
        }
    }
    // Recursively search a directory for source files to test.
    findIgnored(dir) {
        this.logger.debug(`Searching dir: ${dir}`);
        const files = core_1.fs.readdirSync(dir);
        for (const filename of files) {
            this.statIgnored(path.join(dir, filename));
        }
    }
    // Test if a source file is denied, adding any ignored files to
    // the ignoredFiles array for output.
    testIgnored(filepath) {
        const isDenied = this.forceIgnore.denies(filepath);
        let msg = 'ACCEPTED';
        if (isDenied) {
            msg = 'DENIED';
            this.ignoredFiles.push(filepath);
        }
        this.logger.debug(`[${msg}]: ${filepath}`);
    }
}
exports.SourceIgnoredCommand = SourceIgnoredCommand;
SourceIgnoredCommand.description = messages.getMessage('cmdDescription');
SourceIgnoredCommand.requiresProject = true;
SourceIgnoredCommand.flagsConfig = {
    sourcepath: command_1.flags.filepath({
        char: 'p',
        description: messages.getMessage('sourcepathDescription'),
    }),
};

//# sourceMappingURL=list.js.map
