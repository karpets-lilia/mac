"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllOrgShapesFromAuthenticatedOrgs = void 0;
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const getNonScratchOrgs = async (fileNames) => {
    const orgFileNames = (await core_1.fs.readdir(core_1.Global.DIR)).filter((filename) => filename.match(/^00D.{15}\.json$/g));
    const allAuths = await Promise.all(fileNames.map(async (fileName) => {
        try {
            const orgUsername = path_1.basename(fileName, '.json');
            const auth = await core_1.AuthInfo.create({ username: orgUsername });
            const userId = auth === null || auth === void 0 ? void 0 : auth.getFields().userId;
            // no userid?  Definitely an org primary user
            if (!userId) {
                return auth;
            }
            const orgId = auth.getFields().orgId;
            const orgFileName = `${orgId}.json`;
            // if userId, it could be created from password:generate command.  If <orgId>.json doesn't exist, it's also not a secondary user auth file
            if (orgId && !orgFileNames.includes(orgFileName)) {
                return auth;
            }
            // Theory: within <orgId>.json, if the userId is the first entry, that's the primary username.
            if (orgFileNames.includes(orgFileName)) {
                const usernames = (await core_1.fs.readJson(path_1.join(core_1.Global.DIR, orgFileName))).usernames;
                if (usernames && usernames[0] === auth.getFields().username) {
                    return auth;
                }
            }
        }
        catch (error) {
            const logger = await core_1.Logger.child('getNonScratchOrgs');
            logger.warn(`Problem reading file: ${fileName} skipping`);
        }
        return undefined;
    }));
    return allAuths.filter((auth) => !!auth).filter((auth) => !auth.getFields().devHubUsername);
};
const getAllShapesFromOrg = async (authInfo) => {
    const org = await core_1.Org.create({ aliasOrUsername: authInfo.getFields().username });
    const conn = org.getConnection();
    const logger = await core_1.Logger.child(`getAllShapesFromOrg, ${authInfo.getFields().username}`);
    logger.info(`Query org: ${authInfo.getFields().username} for shapes`);
    try {
        const shapesFound = await conn.query("SELECT Id, Status, CreatedBy.Username, CreatedDate FROM ShapeRepresentation WHERE Status IN ( 'Active', 'InProgress' )");
        return shapesFound.records.map((shape) => ({
            orgId: authInfo.getFields().orgId,
            username: authInfo.getFields().username,
            alias: authInfo.getFields().alias,
            shapeId: shape.Id,
            status: shape.Status,
            createdBy: shape.CreatedBy.Username,
            createdDate: shape.CreatedDate,
        }));
    }
    catch (error) {
        if (error.errorCode === 'INVALID_TYPE') {
            return [];
        }
        else {
            logger.error(false, 'Error finding org shapes', error);
            throw error;
        }
    }
};
exports.getAllOrgShapesFromAuthenticatedOrgs = async () => {
    const aliases = await core_1.Aliases.create(core_1.Aliases.getDefaultOptions());
    const authInfos = await getNonScratchOrgs(await core_1.AuthInfo.listAllAuthFiles());
    const shapes = await Promise.all(authInfos.map((authInfo) => getAllShapesFromOrg(authInfo)));
    return shapes.flat().map((item) => { var _a; return ({ ...item, alias: (_a = aliases.getKeysByValue(item.username)) === null || _a === void 0 ? void 0 : _a[0] }); });
};

//# sourceMappingURL=orgShapeListCommand.js.map
