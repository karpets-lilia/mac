import { AsyncOptionalCreatable } from '@salesforce/kit';
import { AnyJson, JsonMap, Optional } from '@salesforce/ts-types';
import { ConfigAggregator } from '../config/configAggregator';
import { OrgUsersConfig } from '../config/orgUsersConfig';
import { SandboxOrgConfig } from '../config/sandboxOrgConfig';
import { Connection } from './connection';
import { AuthFields, AuthInfo } from './authInfo';
export declare type OrganizationInformation = {
    Name: string;
    InstanceName: string;
    IsSandbox: boolean;
    TrialExpirationDate: string | null;
    NamespacePrefix: string | null;
};
/**
 * Provides a way to manage a locally authenticated Org.
 *
 * **See** {@link AuthInfo}
 *
 * **See** {@link Connection}
 *
 * **See** {@link Aliases}
 *
 * **See** {@link Config}
 *
 * ```
 * // Email username
 * const org1: Org = await Org.create({ aliasOrUsername: 'foo@example.com' });
 * // The target-org config property
 * const org2: Org = await Org.create();
 * // Full Connection
 * const org3: Org = await Org.create({
 *   connection: await Connection.create({
 *     authInfo: await AuthInfo.create({ username: 'username' })
 *   })
 * });
 * ```
 *
 * **See** https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_cli_usernames_orgs.htm
 */
export declare class Org extends AsyncOptionalCreatable<Org.Options> {
    private status;
    private configAggregator;
    private logger;
    private connection;
    private options;
    private orgId?;
    /**
     * @ignore
     */
    constructor(options?: Org.Options);
    /**
     * Clean all data files in the org's data path. Usually <workspace>/.sfdx/orgs/<username>.
     *
     * @param orgDataPath A relative path other than "orgs/".
     * @param throwWhenRemoveFails Should the remove org operations throw an error on failure?
     */
    cleanLocalOrgData(orgDataPath?: string, throwWhenRemoveFails?: boolean): Promise<void>;
    /**
     * @ignore
     */
    retrieveOrgUsersConfig(): Promise<OrgUsersConfig>;
    /**
     * Removes the scratch org config file at $HOME/.sfdx/[name].json, any project level org
     * files, all user auth files for the org, matching default config settings, and any
     * matching aliases.
     *
     * @param throwWhenRemoveFails Determines if the call should throw an error or fail silently.
     */
    remove(throwWhenRemoveFails?: boolean): Promise<void>;
    /**
     * Check that this org is a scratch org by asking the dev hub if it knows about it.
     *
     * **Throws** *{@link SfdxError}{ name: 'NotADevHubError' }* Not a Dev Hub.
     *
     * **Throws** *{@link SfdxError}{ name: 'NoResultsError' }* No results.
     *
     * @param devHubUsernameOrAlias The username or alias of the dev hub org.
     */
    checkScratchOrg(devHubUsernameOrAlias?: string): Promise<Partial<AuthFields>>;
    /**
     * Returns the Org object or null if this org is not affiliated with a Dev Hub (according to the local config).
     */
    getDevHubOrg(): Promise<Optional<Org>>;
    /**
     * Returns `true` if the org is a Dev Hub.
     *
     * **Note** This relies on a cached value in the auth file. If that property
     * is not cached, this method will **always return false even if the org is a
     * dev hub**. If you need accuracy, use the {@link Org.determineIfDevHubOrg} method.
     */
    isDevHubOrg(): boolean;
    /**
     * Returns `true` if the org is a Dev Hub.
     *
     * Use a cached value. If the cached value is not set, then check access to the
     * ScratchOrgInfo object to determine if the org is a dev hub.
     *
     * @param forceServerCheck Ignore the cached value and go straight to the server
     * which will be required if the org flips on the dev hub after the value is already
     * cached locally.
     */
    determineIfDevHubOrg(forceServerCheck?: boolean): Promise<boolean>;
    /**
     * Returns `true` if the org is a scratch org.
     *
     * **Note** This relies on a cached value in the auth file. If that property
     * is not cached, this method will **always return false even if the org is a
     * scratch org**. If you need accuracy, use the {@link Org.determineIfScratch} method.
     */
    isScratch(): boolean;
    /**
     * Returns `true` if the org is a scratch org.
     *
     * Use a cached value. If the cached value is not set, then check
     * `Organization.IsSandbox == true && Organization.TrialExpirationDate != null`
     * using {@link Org.retrieveOrganizationInformation}.
     */
    determineIfScratch(): Promise<boolean>;
    /**
     * Returns `true` if the org is a sandbox.
     *
     * **Note** This relies on a cached value in the auth file. If that property
     * is not cached, this method will **always return false even if the org is a
     * sandbox**. If you need accuracy, use the {@link Org.determineIfDevHubOrg} method.
     */
    isSandbox(): boolean;
    /**
     * Returns `true` if the org is a sandbox.
     *
     * Use a cached value. If the cached value is not set, then check
     * `Organization.IsSandbox == true && Organization.TrialExpirationDate == null`
     * using {@link Org.retrieveOrganizationInformation}.
     */
    determineIfSandbox(): Promise<boolean>;
    /**
     * Retrieve a handful of fields from the Organization table in Salesforce. If this does not have the
     * data you need, just use {@link Connection.singleRecordQuery} with `SELECT <needed fields> FROM Organization`.
     *
     * @returns org information
     */
    retrieveOrganizationInformation(): Promise<OrganizationInformation>;
    /**
     * Some organization information is locally cached, such as if the org name or if it is a scratch org.
     * This method populates/updates the filesystem from information retrieved from the org.
     */
    updateLocalInformation(): Promise<void>;
    /**
     * Refreshes the auth for this org's instance by calling HTTP GET on the baseUrl of the connection object.
     */
    refreshAuth(): Promise<void>;
    /**
     * Reads and returns the content of all user auth files for this org as an array.
     */
    readUserAuthFiles(): Promise<AuthInfo[]>;
    /**
     * Adds a username to the user config for this org. For convenience `this` object is returned.
     *
     * ```
     * const org: Org = await Org.create({
     *   connection: await Connection.create({
     *     authInfo: await AuthInfo.create('foo@example.com')
     *   })
     * });
     * const userAuth: AuthInfo = await AuthInfo.create({
     *   username: 'bar@example.com'
     * });
     * await org.addUsername(userAuth);
     * ```
     *
     * @param {AuthInfo | string} auth The AuthInfo for the username to add.
     */
    addUsername(auth: AuthInfo | string): Promise<Org>;
    /**
     * Removes a username from the user config for this object. For convenience `this` object is returned.
     *
     * **Throws** *{@link SfdxError}{ name: 'MissingAuthInfoError' }* Auth info is missing.
     *
     * @param {AuthInfo | string} auth The AuthInfo containing the username to remove.
     */
    removeUsername(auth: AuthInfo | string): Promise<Org>;
    /**
     * Sets the key/value pair in the sandbox config for this org. For convenience `this` object is returned.
     *
     *
     * @param {key} The key for this value
     * @param {value} The value to save
     */
    setSandboxOrgConfigField(field: SandboxOrgConfig.Fields, value: string): Promise<Org>;
    /**
     * Returns an org config field. Returns undefined if the field is not set or invalid.
     */
    getSandboxOrgConfigField(field: SandboxOrgConfig.Fields): Promise<any>;
    /**
     * Retrieves the highest api version that is supported by the target server instance. If the apiVersion configured for
     * Sfdx is greater than the one returned in this call an api version mismatch occurs. In the case of the CLI that
     * results in a warning.
     */
    retrieveMaxApiVersion(): Promise<string>;
    /**
     * Returns the admin username used to create the org.
     */
    getUsername(): Optional<string>;
    /**
     * Returns the orgId for this org.
     */
    getOrgId(): string;
    /**
     * Returns for the config aggregator.
     */
    getConfigAggregator(): ConfigAggregator;
    /**
     * Returns an org field. Returns undefined if the field is not set or invalid.
     */
    getField<T = AnyJson>(key: Org.Fields): T;
    /**
     * Returns a map of requested fields.
     */
    getFields(keys: Org.Fields[]): JsonMap;
    /**
     * Returns the JSForce connection for the org.
     */
    getConnection(): Connection;
    /**
     * Initialize async components.
     */
    protected init(): Promise<void>;
    /**
     * **Throws** *{@link SfdxError}{ name: 'NotSupportedError' }* Throws an unsupported error.
     */
    protected getDefaultOptions(): Org.Options;
    /**
     * Delete an auth info file from the local file system and any related cache information for
     * this Org. You don't want to call this method directly. Instead consider calling Org.remove()
     */
    private removeAuth;
    /**
     * Deletes the users config file
     */
    private removeUsersConfig;
    /**
     * @ignore
     */
    private retrieveSandboxOrgConfig;
    private manageDelete;
    /**
     * Remove the org users auth file.
     *
     * @param throwWhenRemoveFails true if manageDelete should throw or not if the deleted fails.
     */
    private removeUsers;
    /**
     * Remove an associate sandbox config.
     *
     * @param throwWhenRemoveFails true if manageDelete should throw or not if the deleted fails.
     */
    private removeSandboxConfig;
}
export declare namespace Org {
    /**
     * Constructor Options for and Org.
     */
    interface Options {
        aliasOrUsername?: string;
        connection?: Connection;
        aggregator?: ConfigAggregator;
        isDevHub?: boolean;
    }
    /**
     * Scratch Org status.
     */
    enum Status {
        /**
         * The scratch org is active.
         */
        ACTIVE = "ACTIVE",
        /**
         * The scratch org has expired.
         */
        EXPIRED = "EXPIRED",
        /**
         * The org is a scratch Org but no dev hub is indicated.
         */
        UNKNOWN = "UNKNOWN",
        /**
         * The dev hub configuration is reporting an active Scratch org but the AuthInfo cannot be found.
         */
        MISSING = "MISSING"
    }
    /**
     * Org Fields.
     */
    enum Fields {
        /**
         * The org alias.
         */
        ALIAS = "alias",
        CREATED = "created",
        NAME = "name",
        NAMESPACE_PREFIX = "namespacePrefix",
        INSTANCE_NAME = "instanceName",
        TRIAL_EXPIRATION_DATE = "trailExpirationDate",
        /**
         * The Salesforce instance the org was created on. e.g. `cs42`.
         */
        CREATED_ORG_INSTANCE = "createdOrgInstance",
        /**
         * The username of the dev hub org that created this org. Only populated for scratch orgs.
         */
        DEV_HUB_USERNAME = "devHubUsername",
        /**
         * The full url of the instance the org lives on.
         */
        INSTANCE_URL = "instanceUrl",
        /**
         * Is the current org a dev hub org. e.g. They have access to the `ScratchOrgInfo` object.
         */
        IS_DEV_HUB = "isDevHub",
        /**
         * Is the current org a scratch org. e.g. Organization has IsSandbox == true and TrialExpirationDate != null.
         */
        IS_SCRATCH = "isScratch",
        /**
         * Is the current org a dev hub org. e.g. Organization has IsSandbox == true and TrialExpirationDate == null.
         */
        IS_SANDBOX = "isSandbox",
        /**
         * The login url of the org. e.g. `https://login.salesforce.com` or `https://test.salesforce.com`.
         */
        LOGIN_URL = "loginUrl",
        /**
         * The org ID.
         */
        ORG_ID = "orgId",
        /**
         * The `OrgStatus` of the org.
         */
        STATUS = "status",
        /**
         * The snapshot used to create the scratch org.
         */
        SNAPSHOT = "snapshot"
    }
}
