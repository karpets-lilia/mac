"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AliasAccessor = void 0;
const sfdxError_1 = require("../../sfdxError");
const types_1 = require("../types");
class AliasAccessor {
    constructor(globalInfo) {
        this.globalInfo = globalInfo;
    }
    getAll(entity) {
        const all = this.globalInfo.get(types_1.SfInfoKeys.ALIASES) || {};
        if (entity) {
            const value = this.getNameOf(entity);
            return Object.entries(all)
                .filter((entry) => entry[1] === value)
                .map((entry) => entry[0]);
        }
        else {
            return all;
        }
    }
    /**
     * Returns the first alias found for a given entity
     *
     * @param entity the aliasable entity that you want to get the alias of
     */
    get(entity) {
        var _a;
        return (_a = this.getAll(entity).find((alias) => alias)) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Returns the value that corresponds to the given alias if it exists
     *
     * @param alias the alias that corresponds to a value
     */
    getValue(alias) {
        var _a;
        return (_a = this.getAll()[alias]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Returns the username that corresponds to the given alias if it exists
     *
     * @param alias the alias that corresponds to a username
     */
    getUsername(alias) {
        var _a;
        return (_a = this.getAll()[alias]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * If the provided string is an alias, it returns the corresponding value.
     * If the provided string is not an alias, we assume that the provided string
     * is the value and return it.
     *
     * This method is helpful when you don't know if the string you have is a value
     * or an alias.
     *
     * @param valueOrAlias a string that might be a value or might be an alias
     */
    resolveValue(valueOrAlias) {
        var _a;
        return (_a = this.getValue(valueOrAlias)) !== null && _a !== void 0 ? _a : valueOrAlias;
    }
    /**
     * If the provided string is an alias, it returns the corresponding username.
     * If the provided string is not an alias, we assume that the provided string
     * is the username and return it.
     *
     * This method is helpful when you don't know if the string you have is a username
     * or an alias.
     *
     * @param usernameOrAlias a string that might be a username or might be an alias
     */
    resolveUsername(usernameOrAlias) {
        var _a;
        return (_a = this.getUsername(usernameOrAlias)) !== null && _a !== void 0 ? _a : usernameOrAlias;
    }
    /**
     * Set an alias for the given aliasable entity
     *
     * @param alias the alias you want to set
     * @param entity the aliasable entity that's being aliased
     */
    set(alias, entity) {
        const value = this.getNameOf(entity);
        this.globalInfo.set(`${types_1.SfInfoKeys.ALIASES}["${alias}"]`, value);
    }
    /**
     * Updates the alias for the given aliasable entity
     *
     * @param alias the alias you want to set
     * @param entity the aliasable entity that's being aliased
     */
    update(alias, entity) {
        const value = this.getNameOf(entity);
        this.globalInfo.update(`${types_1.SfInfoKeys.ALIASES}["${alias}"]`, value);
    }
    unset(alias) {
        delete this.globalInfo.get(types_1.SfInfoKeys.ALIASES)[alias];
    }
    /**
     * This method unsets all the aliases for the given entity.
     *
     * @param entity the aliasable entity for which you want to unset all aliases
     */
    unsetAll(entity) {
        const aliases = this.getAll(entity);
        aliases.forEach((alias) => this.unset(alias));
    }
    /**
     * Returns the username of given aliasable entity
     */
    getNameOf(entity) {
        var _a;
        if (typeof entity === 'string')
            return entity;
        const aliaseeName = (_a = entity.username) !== null && _a !== void 0 ? _a : entity.user;
        if (!aliaseeName) {
            throw new sfdxError_1.SfdxError(`Invalid aliasee, it must contain a user or username property: ${JSON.stringify(entity)}`);
        }
        return aliaseeName;
    }
}
exports.AliasAccessor = AliasAccessor;
//# sourceMappingURL=aliasAccessor.js.map